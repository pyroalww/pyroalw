
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PyroAI v2 - Enhanced AI Chat Platform</title>
    <meta name="description" content="PyroAI v2 - Enhanced AI chat platform by PyroLLC. Experience intelligent conversations, automatic website previews, JS execution, and more.">
    <meta name="keywords" content="PyroAI, PyroLLC, PyroALW, AI chat, artificial intelligence, chatbot, machine learning, intelligent assistant, website preview, javascript execution, premium AI">
    <meta name="author" content="PyroLLC">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="PyroAI v2 - Enhanced AI Chat Platform">
    <meta property="og:description" content="Experience the next generation of AI chat with PyroAI v2. Featuring integrated website previews, JS execution, and enhanced features.">
    <meta property="og:image" content="https://avatars.githubusercontent.com/u/134533935?v=4">
    <meta property="og:url" content="https://pyrollc.com.tr"> <!-- Update if URL changes -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="PyroAI v2 - Enhanced AI Chat Platform">
    <meta name="twitter:description" content="Enhanced AI chat experience with integrated website previews, JS execution, and more.">
    <link rel="canonical" href="https://pyrollc.com.tr"> <!-- Update if URL changes -->
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/monokai-sublime.min.css"> <!-- Updated Highlight.js Style -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script> <!-- Updated SortableJS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" />

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Lexend:wght@300;400;500;600;700&display=swap');

        :root {
            --primary-color: #7C3AED; /* Purple */
            --primary-color-hover: #9753FF; /* Lighter Purple */
            --secondary-color: #10B981; /* Emerald */
            --background-color: #F9FAFB; /* Very Light Gray */
            --text-color: #1F2937; /* Dark Gray */
            --light-gray: #E5E7EB;
            --medium-gray: #D1D5DB;
            --dark-gray: #6B7280;
            --darker-gray: #374151;
            --code-bg: #F3F4F6; /* Slightly darker than background */
            --shadow-light: rgba(0, 0, 0, 0.06);
            --accent-color: #FBBF24; /* Amber */

            /* Light theme */
            --background-light: var(--background-color);
            --text-light: var(--text-color);
            --sidebar-light: #FFFFFF;
            --message-user-light: var(--primary-color);
            --message-ai-light: #FFFFFF;
            --message-user-text-light: white;
            --message-ai-text-light: var(--text-color);
            --pinned-background-light: #FEF3C7; /* Light Yellow */
            --pinned-border-light: var(--accent-color);
            --js-result-bg-light: #E0F2FE; /* Light Blue Bg */
            --js-result-text-light: #0C4A6E; /* Dark Blue Text */
            --js-result-border-light: #7DD3FC; /* Lighter Blue Border */

            /* Dark Theme */
            --background-dark: #111827; /* Very Dark Blue/Gray */
            --text-dark: #E5E7EB; /* Light Gray */
            --sidebar-dark: #1F2937; /* Dark Gray/Blue */
            --message-user-dark: #7C3AED;
            --message-ai-dark: #374151; /* Darker Gray/Blue */
            --message-user-text-dark: white;
            --message-ai-text-dark: var(--text-dark);
            --code-bg-dark: #2b303b; /* Darker Code Background */
            --shadow-dark: rgba(0, 0, 0, 0.3);
            --pinned-background-dark: #3730A3; /* Indigo */
            --pinned-border-dark: #A5B4FC; /* Light Indigo */
            --js-result-bg-dark: #1E3A8A; /* Dark Blue Bg */
            --js-result-text-dark: #DBEAFE; /* Light Blue Text */
            --js-result-border-dark: #60A5FA; /* Medium Blue Border */

            --toast-success-bg: #ECFDF5;
            --toast-success-text: #065F46;
            --toast-success-border: #10B981;
            --toast-error-bg: #FEF2F2;
            --toast-error-text: #991B1B;
            --toast-error-border: #EF4444;
            --toast-info-bg: #EFF6FF;
            --toast-info-text: #1E40AF;
            --toast-info-border: #3B82F6;
        }

        html, body {
            height: 100%;
            overflow: hidden; /* Prevent body scroll */
        }

        body {
            font-family: 'Lexend', sans-serif;
            background-color: var(--background-light);
            color: var(--text-light);
            transition: background-color 0.3s ease, color 0.3s ease;
            line-height: 1.6;
            font-size: 16px; /* Base font size */
        }

        .app-container {
            display: flex;
            height: 100vh; /* Use vh for full viewport height */
            overflow: hidden; /* Prevent app container scroll */
            border-radius: 0.75rem;
            box-shadow: 0 8px 25px -5px var(--shadow-light), 0 5px 10px -6px var(--shadow-light);
            margin: 1rem;
            background-color: var(--background-light); /* Explicit background */
        }
        @media (max-width: 768px) {
            .app-container {
                border-radius: 0;
                margin: 0;
                height: 100%; /* Use 100% height on mobile? */
                box-shadow: none;
            }
        }

        /* --- Sidebar --- */
        .sidebar {
            width: 300px;
            background-color: var(--sidebar-light);
            border-right: 1px solid var(--light-gray);
            overflow-y: auto;
            transition: width 0.3s ease, transform 0.3s ease;
            z-index: 20;
            box-shadow: 2px 0 5px -2px var(--shadow-light);
            display: flex;
            flex-direction: column;
            flex-shrink: 0; /* Prevent shrinking */
        }

        /* Collapsed State (Desktop) */
        .sidebar-closed { width: 80px; }
        .sidebar-closed .sidebar-title,
        .sidebar-closed .sidebar-content span,
        .sidebar-closed .sidebar-footer span,
        .sidebar-closed #search-conversations,
        .sidebar-closed .conversation-title,
        .sidebar-closed .conversation-actions,
        .sidebar-closed .user-profile span:not(#premium-user-badge),
        .sidebar-closed #new-conversation span,
        .sidebar-closed #premium-button span,
        .sidebar-closed #suggestions-button span,
        .sidebar-closed #open-settings span { display: none; }
        .sidebar-closed .sidebar-header,
        .sidebar-closed .sidebar-footer { padding-left: 1rem; padding-right: 1rem; justify-content: center; }
        .sidebar-closed .sidebar-content h2 i { margin-right: 0; }
        .sidebar-closed .sidebar-content h2 { justify-content: center; }
        .sidebar-closed .conversation-item { justify-content: center; }
        .sidebar-closed #toggle-sidebar-desktop i { transform: rotate(180deg); }


        /* Mobile Sidebar Collapse (translateX) */
        @media (max-width: 768px) {
            .sidebar { position: fixed; height: 100%; z-index: 50; transform: translateX(-100%); width: 280px; box-shadow: 4px 0 15px rgba(0,0,0,0.2); }
            .sidebar.active { transform: translateX(0); }
            /* Reset desktop collapse styles for mobile */
            .sidebar-closed, .sidebar { width: 280px; }
            .sidebar-closed .sidebar-title,
            .sidebar-closed .sidebar-content span,
            .sidebar-closed .sidebar-footer span,
            .sidebar-closed #search-conversations,
            .sidebar-closed .conversation-title,
            .sidebar-closed .conversation-actions,
            .sidebar-closed .user-profile span:not(#premium-user-badge),
            .sidebar-closed #new-conversation span,
            .sidebar-closed #premium-button span,
            .sidebar-closed #suggestions-button span,
            .sidebar-closed #open-settings span { display: inline-block; }
            .sidebar-closed .sidebar-header,
            .sidebar-closed .sidebar-footer { padding: 1.75rem; justify-content: space-between; }
            .sidebar-closed .sidebar-content h2 i { margin-right: 0.75rem; }
            .sidebar-closed .sidebar-content h2 { justify-content: flex-start; }
            .sidebar-closed .conversation-item { justify-content: space-between; }
            .sidebar-closed #toggle-sidebar-desktop { display: none; }
            #mobile-sidebar-toggle { display: block; }
        }

        .sidebar-header { padding: 1.75rem; border-bottom: 1px solid var(--light-gray); display: flex; align-items: center; justify-content: space-between; flex-shrink: 0; }
        .sidebar-logo-area { display: flex; align-items: center; }
        .sidebar-title { font-size: 1.5rem; font-weight: 700; color: var(--text-color); letter-spacing: -0.025em; margin-left: 0.5rem; }
        #toggle-sidebar-desktop, #toggle-sidebar { color: var(--dark-gray); background: none; border: none; padding: 0.5rem; border-radius: 50%; transition: background-color 0.2s ease, color 0.2s ease; cursor: pointer; }
        #toggle-sidebar-desktop:hover, #toggle-sidebar:hover { background-color: var(--light-gray); color: var(--primary-color); }
        #toggle-sidebar { display: none; } /* Mobile toggle hidden by default */
        .sidebar-content { padding: 1.25rem 1.75rem; flex-grow: 1; overflow-y: auto; } /* Allow sidebar content scroll if needed */
        .sidebar-footer { padding: 1.25rem 1.75rem; border-top: 1px solid var(--light-gray); text-align: center; margin-top: auto; flex-shrink: 0; }

        .conversation-list { padding-top: 0.5rem; }
        .conversation-item { padding: 0.75rem; margin-bottom: 0.5rem; border-radius: 0.75rem; cursor: pointer; transition: background-color 0.2s ease, transform 0.15s ease, box-shadow 0.2s ease; display: flex; justify-content: space-between; align-items: center; overflow: hidden; }
        .conversation-item:hover { background-color: var(--light-gray); transform: translateX(3px); box-shadow: 2px 2px 5px var(--shadow-light); }
        .conversation-item.active { background-color: var(--primary-color); color: white; box-shadow: 0 3px 8px -2px rgba(124, 58, 237, 0.5); transform: translateX(3px); }
        .conversation-item.active:hover { background-color: var(--primary-color-hover); }
        .conversation-item.active .text-gray-700, .conversation-item.active .dark-gray, .conversation-item.active .conversation-actions button { color: white !important; } /* Ensure text and icon color changes */
        .conversation-item.active .conversation-actions button:hover { background-color: rgba(255,255,255,0.2); }

        .conversation-title { flex-grow: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-right: 0.5rem; font-size: 0.95rem; }
        .conversation-actions { display: flex; gap: 0.3rem; }
        .conversation-actions button, .conversation-actions-mobile-button { padding: 0.5rem; background: none; border: none; color: var(--dark-gray); cursor: pointer; opacity: 0.8; transition: all 0.2s ease; border-radius: 0.3rem; }
        .conversation-actions button:hover, .conversation-actions-mobile-button:hover { opacity: 1; background-color: rgba(0,0,0,0.05); color: var(--primary-color); transform: scale(1.1); }

        /* Mobile dropdown styles */
        .conversation-actions-mobile-dropdown { position: relative; }
        .conversation-actions-dropdown-content { display: none; position: absolute; right: 0; background-color: var(--sidebar-light); min-width: 140px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.15); z-index: 1; border-radius: 0.5rem; padding: 0.5rem 0; margin-top: 0.2rem; border: 1px solid var(--light-gray); }
        .conversation-actions-dropdown-content.show { display: block; }
        .conversation-actions-dropdown-content button { display: flex; align-items: center; width: 100%; padding: 0.6rem 1rem; text-align: left; clear: both; white-space: nowrap; font-size: 0.9rem; background: none; border: none; color: var(--text-color); } /* Reset button styles */
        .conversation-actions-dropdown-content button:hover { background-color: var(--light-gray); }
        .conversation-actions-dropdown-content i { margin-right: 0.75rem; width: 1em; text-align: center; color: var(--dark-gray); }

        /* --- Chat Area --- */
        .chat-area { flex-grow: 1; display: flex; flex-direction: column; background-color: var(--background-light); overflow: hidden; /* Prevent chat area itself from scrolling */ }
        .chat-header { padding: 1.5rem 1.75rem; border-bottom: 1px solid var(--light-gray); display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; min-height: 70px; }
        .chat-title { font-size: 1.5rem; font-weight: 600; color: var(--text-color); letter-spacing: -0.02em; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 60%; }
        #mobile-sidebar-toggle { display: none; } /* Hidden by default, shown via media query */

        .chat-messages-container {
            flex-grow: 1; /* Take available space */
            padding: 1.75rem;
            overflow-y: auto; /* Allow only this container to scroll */
            scroll-behavior: smooth;
            scrollbar-gutter: stable; /* Prevent layout shift when scrollbar appears */
            padding-bottom: 2rem; /* Space above input */
        }
        /* Placeholder when empty */
        .empty-chat-placeholder { display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; text-align: center; color: var(--dark-gray); }
        .empty-chat-placeholder i { font-size: 3rem; margin-bottom: 1rem; opacity: 0.6; }
        .empty-chat-placeholder p { font-size: 1.1rem; }

        .message-wrapper { margin-bottom: 1.25rem; display: flex; flex-direction: column; max-width: 90%; }
        .message-wrapper.user-message-wrapper { align-self: flex-end; max-width: 85%; }
        .message-wrapper.ai-message-wrapper { align-self: flex-start; max-width: 85%; }

        .message { padding: 0.9rem 1.4rem; border-radius: 1.25rem; word-wrap: break-word; box-shadow: 0 2px 5px 0 var(--shadow-light), 0 1px 2px 0 var(--shadow-light); animation: fadeInUp 0.4s ease-out; position: relative; transition: box-shadow 0.25s ease; user-select: text; line-height: 1.5; width: fit-content; }
        .message-wrapper.user-message-wrapper .message { margin-left: auto; }
        .message-wrapper.ai-message-wrapper .message { margin-right: auto; }
        .message:hover { box-shadow: 0 4px 8px 0 var(--shadow-light), 0 2px 4px 0 var(--shadow-light); }

        .message.user-message { background-color: var(--message-user-light); color: var(--message-user-text-light); border-bottom-right-radius: 0.5rem; }
        .message.ai-message { background-color: var(--message-ai-light); color: var(--message-ai-text-light); border-bottom-left-radius: 0.5rem; }
        .message.image-gen-message, .message.website-code-message, .message.process-js-result-message { background-color: var(--message-ai-light); color: var(--message-ai-text-light); border-bottom-left-radius: 0.5rem; }
        .message.website-code-message { padding: 0; overflow: hidden; } /* Remove padding for preview container */
        .message.process-js-result-message {
            background-color: var(--js-result-bg-light);
            color: var(--js-result-text-light);
            border: 1px solid var(--js-result-border-light);
            border-left: 4px solid var(--primary-color); /* Accent border */
            padding-left: 1rem; /* Add padding for icon */
        }
        .message.process-js-result-message::before { /* Add icon */
            font-family: "Font Awesome 6 Free";
            font-weight: 900;
            content: "\f121"; /* Code icon */
            margin-right: 0.6rem;
            color: var(--primary-color);
        }
        body.dark .message.process-js-result-message { background-color: var(--js-result-bg-dark); color: var(--js-result-text-dark); border-color: var(--js-result-border-dark); }
        body.dark .message.process-js-result-message::before { color: var(--primary-color-hover); }
        .message.process-js-result-message pre { margin-top: 0.5rem; }

        .message-content { font-size: 1rem; }
        .message-content > *:first-child { margin-top: 0; }
        .message-content > *:last-child { margin-bottom: 0; }
        .message-content p { margin-bottom: 0.75em; }
        .message-content ul, .message-content ol { margin-left: 1.5em; margin-bottom: 0.75em; }
        .message-content li { margin-bottom: 0.25em; }
        .message-content blockquote { border-left: 4px solid var(--medium-gray); padding-left: 1em; margin-left: 0; margin-bottom: 0.75em; color: var(--dark-gray); font-style: italic; }
        .message-content a { color: var(--primary-color); text-decoration: underline; }
        body.dark .message-content a { color: var(--primary-color-hover); }

        /* --- Website Preview in Chat (Enhanced) --- */
        .website-preview-area-chat { /* Wrapper div inside the message */
            border-radius: 1.25rem;
            border-top-left-radius: 0;
            border-top-right-radius: 0;
            overflow: hidden;
            background-color: var(--code-bg); /* Background for the area */
        }
        .website-preview-header-chat {
            background-color: var(--darker-gray);
            padding: 0.6rem 1rem;
            font-size: 0.8rem;
            color: var(--background-light); /* Light text on dark header */
            border-bottom: 1px solid var(--medium-gray);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        body.dark .website-preview-header-chat { background-color: #4B5563; color: var(--text-dark); border-bottom-color: #6B7280;}
        .website-preview-header-chat .title { font-weight: 500; }
        .website-preview-header-chat .actions button { background: none; border: none; color: var(--background-light); cursor: pointer; opacity: 0.8; transition: opacity 0.2s ease, transform 0.2s ease; padding: 0.3rem; margin-left: 0.5rem; font-size: 0.9rem; }
        body.dark .website-preview-header-chat .actions button { color: var(--text-dark); }
        .website-preview-header-chat .actions button:hover { opacity: 1; transform: scale(1.15); }
        .website-preview-iframe { width: 100%; height: 350px; border: none; display: block; background-color: white; /* Ensure iframe bg is white */}

        /* --- Other Message Types --- */
        .message-file { display: block; margin-top: 0.75rem; padding: 0.75rem 1rem; border-radius: 0.5rem; background-color: var(--code-bg); color: var(--text-color); text-decoration: none; transition: background-color 0.3s ease; border: 1px solid var(--medium-gray); display: flex; align-items: center; gap: 0.5rem; }
        .message-file:hover { background-color: var(--light-gray); }
        .message-image { max-width: 100%; height: auto; border-radius: 0.75rem; margin-top: 0.75rem; box-shadow: 0 2px 4px 0 var(--shadow-light); }
        .message-time { font-size: 0.75rem; color: var(--dark-gray); margin-top: 0.5rem; align-self: flex-end; opacity: 0.8; }
        .message-wrapper.user-message-wrapper .message-time { color: var(--dark-gray); opacity: 0.8;}
        body.dark .message-wrapper.user-message-wrapper .message-time { color: #9CA3AF; }
        body.dark .message-wrapper.ai-message-wrapper .message-time { color: #9CA3AF; }

        .message-actions { position: absolute; top: -10px; right: 10px; display: flex; gap: 0.5rem; background-color: var(--sidebar-light); padding: 0.2rem 0.5rem; border-radius: 0.75rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1); opacity: 0; transition: opacity 0.2s ease, transform 0.2s ease; transform: translateY(5px); z-index: 2; }
        .message-wrapper:hover .message-actions { opacity: 1; transform: translateY(0); }
        .message-action-button { background: none; border: none; color: var(--dark-gray); cursor: pointer; opacity: 0.7; padding: 0.3rem; border-radius: 50%; transition: all 0.2s ease; font-size: 0.8rem; }
        .message-action-button:hover { opacity: 1; background-color: var(--light-gray); color: var(--primary-color); transform: scale(1.1); }

        /* Context Menu */
        #message-context-menu { position: fixed; z-index: 55; background-color: var(--sidebar-light); border-radius: 0.6rem; box-shadow: 0 5px 15px rgba(0,0,0,0.2); padding: 0.5rem 0; min-width: 160px; display: none; border: 1px solid var(--light-gray); }
        #message-context-menu button { display: flex; align-items: center; width: 100%; padding: 0.7rem 1.2rem; text-align: left; background: none; border: none; color: var(--text-color); transition: background-color 0.2s ease; cursor: pointer; font-size: 0.9rem; }
        #message-context-menu button:hover { background-color: var(--light-gray); }
        #message-context-menu i { margin-right: 0.75rem; width: 1em; text-align: center; color: var(--dark-gray); }

        @keyframes fadeInUp { from { opacity: 0; transform: translateY(15px); } to { opacity: 1; transform: translateY(0); } }

        /* Typing Indicators */
        .typing-indicator, #printing-animation, #image-generating-animation, #process-js-animation, #ollama-generating-animation, #website-generating-animation {
            display: flex; align-items: center; justify-content: flex-start; padding: 0.9rem 1.4rem; border-radius: 1.25rem; background-color: var(--message-ai-light); color: var(--message-ai-text-light); width: fit-content; margin-right: auto; box-shadow: 0 3px 7px 0 var(--shadow-light), 0 1px 3px 0 var(--shadow-light); animation: pulse-shadow 1.5s infinite ease-in-out; align-self: flex-start; /* Ensure alignment */ margin-bottom: 1.25rem; /* Consistent spacing */
        }
        .typing-indicator span, .generating-dot { /* Unified dot style */
            display: inline-block; margin-left: 4px; width: 8px; height: 8px; border-radius: 50%; background-color: var(--dark-gray); opacity: 0.7; animation: typingDots 1.4s infinite ease-in-out;
        }
        .generating-text { margin-right: 6px; font-size: 0.95rem; }
        .typing-indicator span:nth-child(2), .generating-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-indicator span:nth-child(3), .generating-dot:nth-child(3) { animation-delay: 0.4s; }
        /* Specific Icons for Indicators */
        #printing-animation::before { font-family: "Font Awesome 6 Free"; font-weight: 900; content: "\f110"; /* spinner */ margin-right: 0.6rem; animation: fa-spin 1.5s linear infinite; }
        #image-generating-animation::before { font-family: "Font Awesome 6 Free"; font-weight: 900; content: "\f03e"; /* image */ margin-right: 0.6rem; animation: pulse-icon 1.5s infinite ease-in-out; }
        #ollama-generating-animation::before { font-family: "Font Awesome 6 Free"; font-weight: 900; content: "\f233"; /* server */ margin-right: 0.6rem; animation: pulse-icon 1.5s infinite ease-in-out; }
        #website-generating-animation::before { font-family: "Font Awesome 6 Free"; font-weight: 900; content: "\f121"; /* code */ margin-right: 0.6rem; animation: pulse-icon 1.5s infinite ease-in-out; }
        #process-js-animation::before { font-family: "Font Awesome 6 Free"; font-weight: 900; content: "\f542"; /* calculator or terminal */ margin-right: 0.6rem; animation: pulse-icon 1.5s infinite ease-in-out; }


        @keyframes pulse-shadow { 0%, 100% { box-shadow: 0 2px 5px 0 var(--shadow-light), 0 1px 2px 0 var(--shadow-light); transform: scale(1); } 50% { box-shadow: 0 4px 8px 0 var(--shadow-light), 0 2px 4px 0 var(--shadow-light); transform: scale(1.01); } }
        @keyframes pulse-icon { 0%, 100% { transform: scale(1); opacity: 0.8; } 50% { transform: scale(1.1); opacity: 1; } }
        @keyframes typingDots { 0%, 60%, 100% { transform: translateY(0); } 30% { transform: translateY(-4px); } }

        /* --- Input Area --- */
        .chat-input-area {
            padding: 1.25rem 1.75rem;
            background-color: var(--sidebar-light);
            border-top: 1px solid var(--light-gray);
            display: flex;
            flex-direction: column; /* Stack elements vertically */
            align-items: stretch; /* Stretch items horizontally */
            gap: 0.75rem;
            box-shadow: 0 -2px 5px var(--shadow-light);
            position: sticky; /* Keep input area at the bottom */
            bottom: 0;
            z-index: 30;
            flex-shrink: 0; /* Prevent shrinking */
        }
        .chat-input-area-inner { /* New wrapper for horizontal elements */
             display: flex;
             align-items: flex-end; /* Align items to bottom for multiline input */
             gap: 0.75rem;
             width: 100%;
        }

        /* Starter messages only shown when conversation-empty */
        #starter-messages-area { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 0.75rem; margin-bottom: 1rem; width: 100%; display: none; /* Hidden by default */ }
        .chat-input-area.conversation-empty #starter-messages-area { display: grid; /* Show when parent has class */ }
        .starter-message-button { padding: 0.7rem 1rem; border-radius: 0.5rem; background-color: var(--light-gray); color: var(--text-color); border: none; cursor: pointer; font-size: 0.9rem; transition: all 0.2s ease; box-shadow: 0 1px 2px 0 var(--shadow-light); text-align: left; }
        .starter-message-button:hover { background-color: var(--medium-gray); transform: translateY(-2px); box-shadow: 0 2px 4px 0 var(--shadow-light); }

        .image-preview-area {
            position: absolute;
            bottom: calc(100% + 0.5rem); /* Position above input area */
            left: 1.75rem;
            background-color: var(--sidebar-light);
            padding: 0.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 -2px 5px var(--shadow-light);
            z-index: 35; /* Above input area but below modals */
        }
        .image-preview { max-height: 60px; border-radius: 0.3rem; margin-right: 0.5rem; box-shadow: 0 1px 3px 0 var(--shadow-light); }
        .remove-image-btn { position: absolute; top: -8px; right: -8px; background-color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.2); color: var(--dark-gray); font-size: 0.8rem; line-height: 1; transition: all 0.2s ease; }
        .remove-image-btn:hover { background-color: var(--light-gray); transform: scale(1.1); color: var(--primary-color); }

        /* Input field using textarea */
        .chat-input {
            flex-grow: 1;
            padding: 0.9rem 1.4rem;
            border: 1px solid var(--medium-gray);
            border-radius: 0.75rem;
            font-size: 1rem;
            line-height: 1.5rem;
            outline: none;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: inset 0 1px 2px 0 var(--shadow-light);
            background-color: var(--background-light);
            color: var(--text-color);
            resize: none; /* Disable manual resize */
            min-height: 48px; /* Minimum height for single line */
            max-height: 150px; /* Maximum height before scroll */
            overflow-y: auto; /* Add scroll if needed */
        }
        .chat-input:focus { border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.2), inset 0 1px 2px 0 var(--shadow-light); }

        /* Action Buttons in Input Area */
        .input-action-button { padding: 0.75rem; width: 48px; height: 48px; border-radius: 0.75rem; background-color: var(--primary-color); color: white; font-weight: 600; cursor: pointer; border: none; transition: all 0.2s ease; box-shadow: 0 2px 4px 0 var(--shadow-light); display: flex; align-items: center; justify-content: center; flex-shrink: 0; font-size: 1.1rem; }
        .input-action-button:hover { background-color: var(--primary-color-hover); transform: translateY(-2px); box-shadow: 0 3px 7px 0 var(--shadow-light), 0 1px 3px 0 var(--shadow-light); }
        .input-action-button:active { transform: translateY(0px) scale(0.98); }
        .input-action-button:disabled { background-color: var(--medium-gray); cursor: not-allowed; transform: none; box-shadow: 0 2px 4px 0 var(--shadow-light); }
        .attach-button { background-color: var(--light-gray); color: var(--dark-gray); }
        .attach-button:hover { background-color: var(--medium-gray); color: var(--text-color); }
        .attach-button label { cursor: pointer; display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; }

        /* --- Sidebar Buttons --- */
         #new-conversation, #premium-button, #suggestions-button, #open-settings { margin: 0.5rem 0; padding: 0.8rem 1.2rem; border-radius: 0.5rem; width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.75rem; font-size: 0.95rem; font-weight: 500; transition: all 0.2s ease; border: 1px solid transparent; }
        #new-conversation { background-color: var(--primary-color); color: white; border-color: var(--primary-color); }
        #new-conversation:hover { background-color: var(--primary-color-hover); border-color: var(--primary-color-hover); transform: translateY(-2px); box-shadow: 0 2px 5px rgba(124, 58, 237, 0.3); }
        #premium-button { background-color: var(--accent-color); color: white; border-color: var(--accent-color); }
        #premium-button:hover { background-color: #F59E0B; border-color: #F59E0B; transform: translateY(-2px); box-shadow: 0 2px 5px rgba(251, 191, 36, 0.3); }
        #suggestions-button, #open-settings { background-color: var(--sidebar-light); color: var(--dark-gray); border: 1px solid var(--medium-gray); }
        #suggestions-button:hover, #open-settings:hover { background-color: var(--light-gray); color: var(--text-color); border-color: var(--dark-gray); transform: translateY(-2px); box-shadow: 0 2px 5px var(--shadow-light); }

        /* --- Modals --- */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 50; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; backdrop-filter: blur(5px); }
        .modal-overlay.show { opacity: 1; visibility: visible; }
        .modal-content { background-color: var(--sidebar-light); border-radius: 0.8rem; padding: 2rem; max-width: 600px; width: 95%; box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3); transform: scale(0.95); opacity: 0; transition: transform 0.3s ease, opacity 0.3s ease; overflow-y: auto; max-height: 90vh; border: 1px solid var(--light-gray); }
        .modal-overlay.show .modal-content { transform: scale(1); opacity: 1; }
        .modal-header { font-size: 1.6rem; font-weight: 600; margin-bottom: 1.5rem; color: var(--text-color); text-align: center; }
        .modal-body { margin-bottom: 1.75rem; color: var(--text-color); line-height: 1.6; }
        .modal-footer { display: flex; justify-content: flex-end; gap: 0.75rem; }
        .modal-btn { padding: 0.7rem 1.4rem; border-radius: 0.5rem; border: none; cursor: pointer; font-weight: 500; transition: all 0.2s ease; box-shadow: 0 1px 3px 0 var(--shadow-light); }
        .modal-btn:hover { transform: translateY(-2px); box-shadow: 0 2px 5px 0 var(--shadow-light); }
        .modal-btn:active { transform: translateY(0px) scale(0.98); }
        .modal-btn-primary { background-color: var(--primary-color); color: white; }
        .modal-btn-primary:hover { background-color: var(--primary-color-hover); }
        .modal-btn-secondary { background-color: var(--light-gray); color: var(--text-color); }
        .modal-btn-secondary:hover { background-color: var(--medium-gray); }
        .modal-body label { display: block; margin-bottom: 0.5rem; font-weight: 500; }
        .modal-body input[type="text"], .modal-body input[type="number"], .modal-body input[type="date"], .modal-body input[type="email"], .modal-body input[type="password"], .modal-body select, .modal-body textarea { width: 100%; padding: 0.75rem 1rem; border-radius: 0.5rem; border: 1px solid var(--medium-gray); background-color: var(--background-light); color: var(--text-light); transition: border-color 0.2s ease, box-shadow 0.2s ease; margin-top: 0.25rem; }
        .modal-body input:focus, .modal-body select:focus, .modal-body textarea:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.2); }
        .modal-body textarea { min-height: 100px; resize: vertical; }

        /* Dark Mode Styles */
        body.dark {
            --background-color: var(--background-dark);
            --text-color: var(--text-dark);
            --light-gray: #374151;
            --medium-gray: #4B5563;
            --dark-gray: #9CA3AF;
            --darker-gray: #D1D5DB;
            --code-bg: var(--code-bg-dark);
            --shadow-light: var(--shadow-dark);
            --sidebar-light: var(--sidebar-dark);
            --message-user-light: var(--message-user-dark);
            --message-ai-light: var(--message-ai-dark);
            --message-user-text-light: var(--message-user-text-dark);
            --message-ai-text-light: var(--message-ai-text-dark);
            --pinned-background-light: var(--pinned-background-dark);
            --pinned-border-light: var(--pinned-border-dark);
            --js-result-bg-light: var(--js-result-bg-dark);
            --js-result-text-light: var(--js-result-text-dark);
            --js-result-border-light: var(--js-result-border-dark);
            --toast-success-bg: #064E3B;
            --toast-success-text: #A7F3D0;
            --toast-error-bg: #7F1D1D;
            --toast-error-text: #FECACA;
            --toast-info-bg: #1E3A8A;
            --toast-info-text: #BFDBFE;
        }
        body.dark .app-container { background-color: var(--background-dark); box-shadow: 0 8px 25px -5px var(--shadow-dark), 0 5px 10px -6px var(--shadow-dark); }
        body.dark .sidebar, body.dark .chat-input-area, body.dark .modal-content, body.dark .chat-header { border-color: var(--medium-gray); }
        body.dark .chat-input-area { background-color: var(--sidebar-dark); box-shadow: 0 -2px 5px var(--shadow-dark); }
        body.dark .chat-input { background-color: #4B5563; color: var(--text-dark); border-color: #6B7280; box-shadow: inset 0 1px 2px 0 rgba(0,0,0,0.2); }
        body.dark .chat-input:focus { border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.3), inset 0 1px 2px 0 rgba(0,0,0,0.2); }
        body.dark .conversation-item:hover { background-color: #374151; }
        body.dark .conversation-item.active { background-color: var(--primary-color); }
        body.dark .conversation-item.active:hover { background-color: var(--primary-color-hover); }
        body.dark .modal-content { background-color: #1F2937; border-color: var(--medium-gray); }
        body.dark .modal-overlay { background-color: rgba(0, 0, 0, 0.7); }
        body.dark .message.ai-message { background-color: var(--message-ai-dark); }
        body.dark .message-content blockquote { color: var(--darker-gray); border-left-color: var(--dark-gray); }
        body.dark .starter-message-button { background-color: #374151; color: var(--text-dark); box-shadow: 0 1px 2px 0 rgba(0,0,0,0.3); }
        body.dark .starter-message-button:hover { background-color: #4B5563; }
        body.dark .attach-button { background-color: #374151; color: #9CA3AF; }
        body.dark .attach-button:hover { background-color: #4B5563; color: var(--text-dark); }
        body.dark #new-conversation:hover { box-shadow: 0 2px 5px rgba(124, 58, 237, 0.4); }
        body.dark #premium-button:hover { box-shadow: 0 2px 5px rgba(251, 191, 36, 0.4); }
        body.dark #suggestions-button:hover, body.dark #open-settings:hover { background-color: #374151; color: var(--text-dark); border-color: #6B7280; box-shadow: 0 2px 5px var(--shadow-dark); }
        body.dark .modal-body input, body.dark .modal-body select, body.dark .modal-body textarea { background-color: #374151; border-color: #6B7280; color: var(--text-dark); }
        body.dark .modal-body input:focus, body.dark .modal-body select:focus, body.dark .modal-body textarea:focus { border-color: var(--primary-color); box-shadow: 0 0 0 2px rgba(124, 58, 237, 0.3); }
        body.dark .website-preview-area-chat { background-color: var(--code-bg-dark); }
        body.dark .message-file { background-color: var(--code-bg-dark); color: var(--text-dark); border-color: var(--medium-gray); }
        body.dark .message-file:hover { background-color: var(--light-gray); }
        body.dark .conversation-actions-dropdown-content { background-color: var(--sidebar-dark); border-color: var(--medium-gray); }
        body.dark .conversation-actions-dropdown-content button { color: var(--text-dark); }
        body.dark .conversation-actions-dropdown-content button:hover { background-color: var(--light-gray); }
        body.dark .conversation-actions-dropdown-content i { color: var(--dark-gray); }
        body.dark #message-context-menu { background-color: var(--sidebar-dark); border-color: var(--medium-gray); }
        body.dark #message-context-menu button { color: var(--text-dark); }
        body.dark #message-context-menu button:hover { background-color: var(--light-gray); }
        body.dark #message-context-menu i { color: var(--dark-gray); }
        body.dark .typing-indicator, body.dark #printing-animation, body.dark #image-generating-animation, body.dark #process-js-animation, body.dark #ollama-generating-animation, body.dark #website-generating-animation { background-color: var(--message-ai-dark); color: var(--message-ai-text-dark); box-shadow: 0 3px 7px 0 var(--shadow-dark), 0 1px 3px 0 var(--shadow-dark); }
        body.dark .typing-indicator span, body.dark .generating-dot { background-color: var(--dark-gray); }

        /* Highlight.js Dark Mode */
        body.dark .hljs { background: var(--code-bg-dark); color: #abb2bf; }
        body.dark .hljs-keyword { color: #C678DD; }
        body.dark .hljs-built_in { color: #E6C07B; }
        body.dark .hljs-string { color: #98C379; }
        body.dark .hljs-comment { color: #5C6370; font-style: italic; }
        body.dark .hljs-number { color: #D19A66; }
        body.dark .hljs-function { color: #61AFEF; }
        body.dark .hljs-title.function_ { color: #61AFEF; }
        body.dark .hljs-params { color: #ABB2BF; }
        body.dark .hljs-meta { color: #ABB2BF; }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background-color: var(--medium-gray); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background-color: var(--dark-gray); }
        body.dark ::-webkit-scrollbar-thumb { background-color: #4B5563; }
        body.dark ::-webkit-scrollbar-thumb:hover { background-color: #6B7280; }

        /* Pinned Conversation */
        .pinned-conversation { background-color: var(--pinned-background-light); border-left: 4px solid var(--pinned-border-light); }
        body.dark .pinned-conversation { background-color: var(--pinned-background-dark); border-left-color: var(--pinned-border-dark); color: var(--text-dark); }
        body.dark .pinned-conversation:hover { background-color: rgba(55, 48, 163, 0.8); } /* Slightly lighter dark pin */
        .pinned-conversation:hover { background-color: #FEF9C3; } /* Lighter yellow */
        .pinned-conversation.active { background-color: var(--primary-color) !important; color: white !important; border-left-color: var(--primary-color-hover) !important; }

        /* Premium Badge */
        .premium-badge { display: inline-flex; align-items: center; justify-content: center; padding: 0.15rem 0.5rem; border-radius: 1rem; font-size: 0.7rem; font-weight: 600; color: #422006; background-color: var(--accent-color); margin-left: 0.5rem; vertical-align: middle; line-height: 1; animation: pulse-badge 2.5s infinite ease-in-out; }
        @keyframes pulse-badge { 0%, 100% { transform: scale(1); opacity: 0.9; } 50% { transform: scale(1.08); opacity: 1; } }

        /* Memory Update Message */
        .memory-update-message { background-color: var(--pinned-background-light); color: #92400E; border: 1px solid var(--pinned-border-light); padding: 0.6rem 1.1rem; border-radius: 0.75rem; margin: 0.5rem auto 1.25rem auto; /* Add margin bottom */ max-width: 80%; font-size: 0.9rem; text-align: center; box-shadow: 0 1px 3px 0 var(--shadow-light); animation: fadeIn 0.4s ease-out; align-self: center; }
        body.dark .memory-update-message { background-color: #312E81; border-color: var(--pinned-border-dark); color: #C7D2FE; box-shadow: 0 1px 3px 0 var(--shadow-dark); }

        /* Input Validation */
        input:invalid, textarea:invalid { border-color: #EF4444 !important; }
        input:focus:invalid, textarea:focus:invalid { box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.3) !important; }
        .error-message { color: #EF4444; font-size: 0.875rem; margin-top: 0.25rem; display: block; }
        .hidden { display: none !important; }

        /* Code Block Styling */
        pre { position: relative; margin-bottom: 1em; }
        code.hljs { background: var(--code-bg); color: var(--text-color); border-radius: 0.6rem; padding: 1rem; overflow-x: auto; font-size: 0.9rem; line-height: 1.4; display: block; border: 1px solid var(--light-gray); }
        body.dark code.hljs { background: var(--code-bg-dark); color: var(--text-dark); border-color: var(--medium-gray); }
        .copy-code-button { position: absolute; top: 0.5rem; right: 0.5rem; background-color: rgba(0, 0, 0, 0.5); color: white; border: none; padding: 0.3rem 0.6rem; border-radius: 0.3rem; cursor: pointer; opacity: 0; transition: opacity 0.2s ease; font-size: 0.8rem; z-index: 1; }
        pre:hover .copy-code-button { opacity: 1; }
        .copy-code-button:hover { background-color: rgba(0, 0, 0, 0.7); }

        /* Toast Notifications */
        #toast-container { position: fixed; top: 20px; right: 20px; z-index: 1000; display: flex; flex-direction: column; align-items: flex-end; gap: 0.75rem; }
        .toast { background-color: #fff; color: var(--text-light); padding: 0.8rem 1.2rem; border-radius: 0.5rem; box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15); opacity: 0; min-width: 250px; max-width: 350px; border-left-width: 4px; border-style: solid; display: flex; align-items: center; gap: 0.5rem; animation: slideInRight 0.3s ease-out forwards, fadeOut 0.3s ease-in forwards 3.2s; }
        .toast i { font-size: 1.1rem; }
        .toast.success { border-color: var(--toast-success-border); background-color: var(--toast-success-bg); color: var(--toast-success-text); }
        .toast.error { border-color: var(--toast-error-border); background-color: var(--toast-error-bg); color: var(--toast-error-text); }
        .toast.info { border-color: var(--toast-info-border); background-color: var(--toast-info-bg); color: var(--toast-info-text); }
        body.dark .toast { box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3); }
        body.dark .toast.success { background-color: var(--toast-success-bg); color: var(--toast-success-text); }
        body.dark .toast.error { background-color: var(--toast-error-bg); color: var(--toast-error-text); }
        body.dark .toast.info { background-color: var(--toast-info-bg); color: var(--toast-info-text); }

        @keyframes slideInRight { from { opacity: 0; transform: translateX(100%); } to { opacity: 1; transform: translateX(0); } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }

        /* Mobile Adjustments */
        @media (max-width: 768px) {
            body { font-size: 15px; }
            .app-container { margin: 0; border-radius: 0; height: 100%; /* Ensure full height on mobile */ }
            .chat-area { width: 100%; }
            .sidebar-header, .sidebar-footer { padding: 1.2rem; }
            .sidebar-content { padding: 1rem; }
            .sidebar-title { font-size: 1.3rem; }
            #toggle-sidebar-desktop { display: none; }
            #toggle-sidebar { display: block; }
            .chat-header { padding: 0.8rem; min-height: 60px; }
            .chat-title { font-size: 1.1rem; max-width: calc(100% - 120px); }
            #mobile-sidebar-toggle { display: block; margin-right: 0.5rem; padding: 0.5rem; color: var(--dark-gray); }
            .chat-messages-container { padding: 0.8rem; padding-bottom: 1rem; }
            .message { max-width: 90%; padding: 0.7rem 1rem; font-size: 0.95rem; }
            .message-wrapper { max-width: 95%; }
            .message-actions { display: none !important; } /* Hide hover actions on mobile, rely on long press/context menu */
            .chat-input-area { padding: 0.8rem; gap: 0.5rem; /* position: sticky already set */ }
            .chat-input { padding: 0.7rem 1rem; font-size: 0.95rem; min-height: 42px; max-height: 120px; }
            .input-action-button { width: 42px; height: 42px; font-size: 1rem; }
            .image-preview-area { left: 0.8rem; bottom: calc(100% + 0.5rem); }
            .modal-content { width: 90%; padding: 1.2rem; }
            .modal-header { font-size: 1.3rem; margin-bottom: 1rem; }
            #starter-messages-area { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); }
        }
    </style>
</head>
<body class="bg-gray-100">

    <!-- Toast Notification Container -->
    <div id="toast-container"></div>

    <!-- Message Context Menu -->
    <div id="message-context-menu" class="animate__animated animate__faster" style="display:none;">
        <button id="edit-context-button"><i class="fas fa-edit"></i> Edit</button>
        <button id="copy-context-button"><i class="fas fa-copy"></i> Copy</button>
        <button id="regenerate-context-button"><i class="fas fa-sync"></i> Regenerate</button>
        <button id="delete-context-button"><i class="fas fa-trash"></i> Delete</button>
    </div>

    <!-- Modals -->
    <!-- Welcome Modal -->
    <div id="welcome-modal" class="modal-overlay" style="display: none;">
         <div class="modal-content animate__animated animate__fadeIn animate__faster">
            <h2 class="modal-header"><i class="fas fa-magic mr-2 text-primary-500"></i> Welcome to <span class="font-extrabold">PyroAI v2</span>!</h2>
            <div class="modal-body">
                <p class="mb-4">
                    Explore enhanced AI conversations with PyroAI v2, now featuring dynamic website previews, in-browser code execution, and more! Before you start, please acknowledge these terms:
                </p>
                <ul class="list-disc list-inside mb-4 space-y-1">
                    <li><span class="font-semibold">Beta Program:</span> Features are continually improving. Expect potential bugs and report them via Feedback.</li>
                    <li><span class="font-semibold">Conversation Logging:</span> Conversations may be logged for improvement and quality assurance.</li>
                    <li><span class="font-semibold">Data Sensitivity:</span> Avoid sharing sensitive personal information. PyroLLC is not responsible for user-shared data.</li>
                    <li><span class="font-semibold">Code Execution:</span> The AI can request execution of JavaScript code in your browser (<code class="text-xs bg-gray-200 dark:bg-gray-700 px-1 rounded">&lt;processJS:...&gt;</code>). Use this feature cautiously.</li>
                    <li><span class="font-semibold">Service "As Is":</span> Provided without warranties.</li>
                    <li><span class="font-semibold">Terms Agreement:</span> By using PyroAI, you agree to these terms.</li>
                </ul>
                <p>Thank you for being part of the PyroAI community!</p>
            </div>
            <div class="modal-footer">
                <button id="accept-terms" class="modal-btn modal-btn-primary w-full">
                    <i class="fas fa-check-circle mr-2"></i> I Accept & Enter PyroAI
                </button>
            </div>
        </div>
    </div>

    <!-- Initial Setup Modal -->
    <div id="initial-setup-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content animate__animated animate__fadeIn">
            <h2 class="modal-header"><i class="fas fa-user-cog mr-2 text-primary-500"></i> Setup Your PyroAI Account</h2>
            <div class="modal-body">
                <p class="mb-6">Personalize your experience. This helps tailor interactions and keep things organized.</p>
                <div class="mb-4">
                    <label for="setup-username"><i class="fas fa-user mr-2"></i>Username</label>
                    <input type="text" id="setup-username" placeholder="Choose a username (3-20 chars)" required minlength="3" maxlength="20">
                    <p id="username-error" class="error-message hidden">Username must be 3-20 characters.</p>
                </div>
                <div class="mb-4">
                    <label for="setup-dob"><i class="fas fa-calendar-alt mr-2"></i>Date of Birth</label>
                    <input type="date" id="setup-dob" required>
                    <p id="dob-error" class="error-message hidden">Please select your date of birth (must be 18+).</p>
                </div>
                <div class="mb-4">
                    <label for="setup-email"><i class="fas fa-envelope mr-2"></i>Email Address (Optional)</label>
                    <input type="email" id="setup-email" placeholder="Your email for recovery (optional)">
                    <p id="email-error" class="error-message hidden">Invalid email format.</p>
                </div>
                <div class="mb-4">
                    <label for="setup-pin"><i class="fas fa-lock mr-2"></i>Create PIN (4 digits)</label>
                    <input type="password" id="setup-pin" placeholder="4-digit PIN for security" required pattern="[0-9]{4}" inputmode="numeric" maxlength="4">
                    <p id="pin-error" class="error-message hidden">PIN must be exactly 4 digits.</p>
                </div>
            </div>
            <div class="modal-footer">
                <button id="complete-setup" class="modal-btn modal-btn-primary w-full">
                    <i class="fas fa-check-circle mr-2"></i> Complete Setup
                </button>
            </div>
        </div>
    </div>

    <!-- Age Block Modal -->
    <div id="age-block-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content animate__animated animate__fadeIn">
            <h2 class="modal-header"><i class="fas fa-ban mr-2 text-red-500"></i> Access Denied</h2>
            <div class="modal-body">
                <p class="mb-4">You must be 18 years or older to use PyroAI. Access is restricted based on the date of birth provided.</p>
            </div>
            <div class="modal-footer">
                <button id="close-age-block" class="modal-btn modal-btn-secondary w-full">
                    <i class="fas fa-times-circle mr-2"></i> Close
                </button>
            </div>
        </div>
    </div>

    <!-- Premium Key Modal -->
    <div id="premium-key-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content animate__animated animate__zoomIn">
            <h2 class="modal-header"><i class="fas fa-crown mr-2 text-yellow-500"></i> Activate Premium</h2>
            <div class="modal-body">
                <p class="mb-4">Enter your Premium Key to unlock enhanced features, higher limits, advanced models, and more capabilities.</p>
                <div class="mb-4">
                    <label for="premium-key-input"><i class="fas fa-key mr-2"></i> Premium Key</label>
                    <input type="text" id="premium-key-input" placeholder="Enter your premium key">
                </div>
                <div id="premium-key-status" class="error-message hidden"><i class="fas fa-exclamation-triangle mr-1"></i> Invalid key. Please try again.</div>
            </div>
            <div class="modal-footer">
                <button id="cancel-premium-key" class="modal-btn modal-btn-secondary"><i class="fas fa-ban mr-2"></i> Cancel</button>
                <button id="activate-premium" class="modal-btn modal-btn-primary"><i class="fas fa-lock-open mr-2"></i> Activate</button>
            </div>
        </div>
    </div>

    <!-- Premium Ad Modal (Improved) -->
    <div id="premium-ad-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content animate__animated animate__fadeIn">
            <h2 class="modal-header"><i class="fas fa-rocket mr-2 text-yellow-500"></i> Upgrade to PyroAI Premium!</h2>
            <div class="modal-body">
                <p class="mb-5 text-lg text-center">Unlock the full potential of AI conversations!</p>
                <p class="mb-4">Go beyond the limits and access powerful features designed for demanding users and creative exploration:</p>
                <ul class="list-disc list-inside mb-5 space-y-1 text-left">
                    <li><i class="fas fa-bolt mr-2 text-primary-500"></i> Access to advanced models like <span class="font-semibold">PyroAI Max</span>.</li>
                    <li><i class="fas fa-infinity mr-2 text-primary-500"></i> Significantly <span class="font-semibold">higher message limits</span> per chat & daily.</li>
                    <li><i class="fas fa-comments mr-2 text-primary-500"></i> Create <span class="font-semibold">unlimited conversations</span>.</li>
                    <li><i class="fas fa-image mr-2 text-primary-500"></i> Generate stunning <span class="font-semibold">images</span> with AI.</li>
                    <li><i class="fas fa-file-code mr-2 text-primary-500"></i> Handle more complex requests and <span class="font-semibold">longer messages</span>.</li>
                </ul>

                <div class="overflow-x-auto mb-4 rounded-lg border border-gray-200 dark:border-gray-600">
                    <table class="min-w-full leading-normal">
                        <thead class="bg-gray-100 dark:bg-gray-700">
                            <tr>
                                <th class="px-3 py-2 border-b-2 border-gray-200 dark:border-gray-600 text-left text-xs font-semibold uppercase tracking-wider">Feature</th>
                                <th class="px-3 py-2 border-b-2 border-gray-200 dark:border-gray-600 text-center text-xs font-semibold uppercase tracking-wider">Free</th>
                                <th class="px-3 py-2 border-b-2 border-gray-200 dark:border-gray-600 text-center text-xs font-semibold uppercase tracking-wider text-yellow-500">Premium <i class="fas fa-crown ml-1"></i></th>
                            </tr>
                        </thead>
                        <tbody class="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                             <tr> <td class="px-3 py-3 text-sm">AI Models</td> <td class="px-3 py-3 text-sm text-center">Flash</td> <td class="px-3 py-3 text-sm font-semibold text-primary-500 text-center">Flash, Pro, <span class="whitespace-nowrap">Max <i class="fas fa-star text-xs"></i></span></td> </tr>
                             <tr> <td class="px-3 py-3 text-sm">Messages per Chat</td> <td class="px-3 py-3 text-sm text-center">15</td> <td class="px-3 py-3 text-sm font-semibold text-primary-500 text-center">40</td> </tr>
                             <tr> <td class="px-3 py-3 text-sm">Max Conversations</td> <td class="px-3 py-3 text-sm text-center">3</td> <td class="px-3 py-3 text-sm font-semibold text-primary-500 text-center"><i class="fas fa-infinity"></i></td> </tr>
                             <tr> <td class="px-3 py-3 text-sm">Daily Messages</td> <td class="px-3 py-3 text-sm text-center">10</td> <td class="px-3 py-3 text-sm font-semibold text-primary-500 text-center">100</td> </tr>
                             <tr> <td class="px-3 py-3 text-sm">Daily Images/Files</td> <td class="px-3 py-3 text-sm text-center">3</td> <td class="px-3 py-3 text-sm font-semibold text-primary-500 text-center">20</td> </tr>
                             <tr> <td class="px-3 py-3 text-sm">Message Characters</td> <td class="px-3 py-3 text-sm text-center">1,000</td> <td class="px-3 py-3 text-sm font-semibold text-primary-500 text-center">10,000</td> </tr>
                             <tr> <td class="px-3 py-3 text-sm">Image Generation</td> <td class="px-3 py-3 text-sm text-center"><i class="fas fa-times text-red-500"></i></td> <td class="px-3 py-3 text-sm font-semibold text-primary-500 text-center"><i class="fas fa-check text-green-500"></i> Yes</td> </tr>
                             <tr> <td class="px-3 py-3 text-sm">JS Execution</td> <td class="px-3 py-3 text-sm text-center"><i class="fas fa-check text-green-500"></i> Yes</td> <td class="px-3 py-3 text-sm font-semibold text-primary-500 text-center"><i class="fas fa-check text-green-500"></i> Yes</td> </tr>
                        </tbody>
                    </table>
                </div>
                <p class="text-sm text-center text-gray-600 dark:text-gray-400">Ready to supercharge your AI experience?</p>
            </div>
            <div class="modal-footer">
                <button id="close-premium-ad" class="modal-btn modal-btn-secondary"><i class="fas fa-times-circle mr-2"></i> Continue Free</button>
                <button id="go-premium-ad" class="modal-btn modal-btn-primary animate__animated animate__pulse animate__infinite animate__slow"><i class="fas fa-crown mr-2"></i> Activate Premium Now!</button>
            </div>
        </div>
    </div>

    <!-- Suggestions Modal -->
    <div id="suggestions-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content animate__animated animate__zoomIn">
            <h2 class="modal-header"><i class="fas fa-comment-dots mr-2"></i> Suggestions & Complaints</h2>
            <div class="modal-body">
                <p class="mb-4">We value your feedback! Share your suggestions or complaints to help us improve PyroAI.</p>
                <div class="mb-4">
                    <label for="suggestion-textarea"><i class="fas fa-pen-alt mr-2"></i> Your Feedback</label>
                    <textarea id="suggestion-textarea" rows="5" placeholder="Enter your feedback here..."></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button id="cancel-suggestions" class="modal-btn modal-btn-secondary"><i class="fas fa-ban mr-2"></i> Cancel</button>
                <button id="suggestions-send" class="modal-btn modal-btn-primary"><i class="fas fa-paper-plane mr-2"></i> Send Feedback</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content animate__animated animate__zoomIn">
            <h2 class="modal-header"><i class="fas fa-cog mr-2"></i> Settings</h2>
            <div class="modal-body space-y-5">
                 <div>
                    <label for="theme"><i class="fas fa-palette mr-2"></i> Theme</label>
                    <select id="theme">
                        <option value="light">Light</option>
                        <option value="dark">Dark</option>
                        <option value="system">System</option>
                    </select>
                </div>
                 <div>
                    <label for="message-history-limit"><i class="fas fa-history mr-2"></i> Message History Limit (per chat)</label>
                    <input type="number" id="message-history-limit" value="50" min="10" max="100">
                     <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">Max messages sent to AI for context (default: 50).</p>
                </div>
                 <div>
                    <label for="ai-model"><i class="fas fa-brain mr-2"></i> Gemini API Model</label>
                    <select id="ai-model">
                        {/* Options loaded by JS */}
                    </select>
                    <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">Select the Gemini model (Premium required for Pro/Max).</p>
                </div>
                <div class="border-t border-gray-200 dark:border-gray-600 pt-4">
                     <div class="flex items-center mb-3">
                        <input type="checkbox" id="ollama-enabled" class="mr-2 h-4 w-4 rounded border-gray-300 text-primary-600 focus:ring-primary-500">
                        <label for="ollama-enabled" class="font-medium flex items-center"><i class="fas fa-server mr-2"></i> Enable Ollama API (Local)</label>
                    </div>
                    <p class="text-xs text-gray-500 dark:text-gray-400 mb-3">Use a local Ollama server (if running) instead of Google's Gemini API.</p>
                     <div id="ollama-settings" class="space-y-4 hidden pl-4 border-l-2 border-gray-200 dark:border-gray-600 ml-2">
                         <div>
                            <label for="ollama-api-url"><i class="fas fa-link mr-2"></i> Ollama API URL</label>
                            <input type="text" id="ollama-api-url" placeholder="http://localhost:11434">
                        </div>
                        <div>
                            <label for="ollama-model"><i class="fas fa-laptop-code mr-2"></i> Ollama Model</label>
                            <select id="ollama-model">
                                <option value="deepseek-coder:6.7b-instruct-q8_0">deepseek-coder:6.7b-instruct</option>
                                <option value="llama3:8b-instruct-q8_0">llama3:8b-instruct</option>
                                <option value="gemma:7b-instruct-q8_0">gemma:7b-instruct</option>
                                <option value="mistral:7b-instruct-v0.2-q8_0">mistral:7b-instruct</option>
                                <option value="phi3:3.8b-mini-instruct-4k-q8_0">phi3:3.8b-mini-instruct</option>
                                {/* Add other relevant models */}
                            </select>
                        </div>
                     </div>
                </div>
                 <div>
                    <label for="ai-assistant-mode"><i class="fas fa-magic mr-2"></i> New Assistant Prompt Mode</label>
                    <select id="ai-assistant-mode">
                        <option value="auto">Auto-generate Prompt</option>
                        <option value="manual">Manual Prompt</option>
                    </select>
                </div>
                <div class="border-t border-gray-200 dark:border-gray-600 pt-4">
                    <label><i class="fas fa-memory mr-2"></i> Memory Management</label>
                    <div id="memory-list" class="mt-2 text-sm max-h-40 overflow-y-auto bg-gray-50 dark:bg-gray-700 p-3 rounded border border-gray-200 dark:border-gray-600">
                        {/* Memory items loaded by JS */}
                    </div>
                     <button id="clear-memory" class="modal-btn modal-btn-secondary mt-3 w-full text-sm py-2">
                        <i class="fas fa-trash mr-2"></i> Clear All Memories
                    </button>
                </div>
            </div>
            <div class="modal-footer">
                <button id="close-settings" class="modal-btn modal-btn-secondary"><i class="fas fa-ban mr-2"></i> Cancel</button>
                <button id="save-settings" class="modal-btn modal-btn-primary"><i class="fas fa-save mr-2"></i> Save Settings</button>
            </div>
        </div>
    </div>

    <!-- Change Assistant Modal -->
    <div id="assistant-modal" class="modal-overlay" style="display: none;">
         <div class="modal-content animate__animated animate__zoomIn">
            <h2 class="modal-header"><i class="fas fa-robot mr-2"></i> AI Assistants</h2>
            <p class="text-center text-sm text-gray-600 dark:text-gray-400 -mt-4 mb-4">Select an assistant to define the AI's personality and capabilities for the current chat.</p>
            <div id="assistant-list" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4 modal-body max-h-[60vh] overflow-y-auto p-1">
                 {/* Assistant cards loaded by JS */}
            </div>
            <div class="modal-footer flex-col items-stretch space-y-2">
                 <button id="new-assistant" class="modal-btn modal-btn-primary w-full">
                    <i class="fas fa-plus mr-2"></i> New Assistant
                </button>
                <div class="flex gap-2">
                    <button id="import-assistant" class="modal-btn modal-btn-secondary flex-1">
                        <i class="fas fa-file-import mr-2"></i> Import
                    </button>
                     <button id="export-assistants" class="modal-btn modal-btn-secondary flex-1">
                        <i class="fas fa-file-export mr-2"></i> Export All
                    </button>
                </div>
                <button id="close-assistant-modal" class="modal-btn modal-btn-secondary w-full"><i class="fas fa-times mr-2"></i> Close</button>
            </div>
        </div>
    </div>

    <!-- New/Edit Assistant Modal -->
    <div id="new-assistant-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content animate__animated animate__zoomIn">
            <h2 id="new-assistant-modal-title" class="modal-header"><i class="fas fa-plus-circle mr-2"></i> Create New Assistant</h2>
            <div class="modal-body space-y-4">
                <input type="hidden" id="editing-assistant-id">
                <div>
                    <label for="assistant-name"><i class="fas fa-user-tag mr-2"></i> Assistant Name</label>
                    <input type="text" id="assistant-name" placeholder="e.g., Code Helper, Story Writer" required>
                </div>
                <div>
                    <label for="assistant-description"><i class="fas fa-info-circle mr-2"></i> Description (Optional)</label>
                    <input type="text" id="assistant-description" placeholder="Short description for identification">
                </div>
                <div id="prompt-mode-manual-area">
                    <label for="assistant-prompt"><i class="fas fa-file-alt mr-2"></i> System Prompt</label>
                    <textarea id="assistant-prompt" rows="6" placeholder="Define the AI's role, personality, capabilities, and instructions... Be specific! Mention available tools like <imageGen>, <processJS>, <Memory> if needed." required></textarea>
                    <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">Clearly define behavior and capabilities. Use tags like <code class="text-xs bg-gray-200 dark:bg-gray-700 px-1 rounded">&lt;imageGen:"prompt"&gt;</code>, <code class="text-xs bg-gray-200 dark:bg-gray-700 px-1 rounded">&lt;processJS:"code","output:Bool"&gt;</code>, <code class="text-xs bg-gray-200 dark:bg-gray-700 px-1 rounded">&lt;Memory:"key:value"&gt;</code>.</p>
                </div>
                 <div id="prompt-mode-auto-area" class="hidden text-center p-4 border border-dashed border-gray-300 dark:border-gray-600 rounded-md">
                    <p class="text-gray-700 dark:text-gray-300 text-sm"><i class="fas fa-spinner fa-spin mr-2"></i> Generating system prompt based on name and description...</p>
                </div>
            </div>
            <div class="modal-footer">
                <button id="cancel-new-assistant" class="modal-btn modal-btn-secondary"><i class="fas fa-ban mr-2"></i> Cancel</button>
                <button id="generate-assistant-prompt" class="modal-btn modal-btn-secondary" style="display:none;"><i class="fas fa-magic mr-2"></i> Generate Prompt</button>
                <button id="save-new-assistant" class="modal-btn modal-btn-primary"><i class="fas fa-save mr-2"></i> Save Assistant</button>
            </div>
        </div>
    </div>

    <!-- Edit Message Modal -->
    <div id="edit-message-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content animate__animated animate__zoomIn">
            <h2 class="modal-header"><i class="fas fa-edit mr-2"></i> Edit Message</h2>
            <div class="modal-body">
                <label for="edit-message-textarea"><i class="fas fa-pen-to-square mr-2"></i> Edit your message below:</label>
                <textarea id="edit-message-textarea" rows="6"></textarea>
            </div>
            <div class="modal-footer">
                <button id="cancel-edit-message" class="modal-btn modal-btn-secondary"><i class="fas fa-ban mr-2"></i> Cancel</button>
                <button id="save-edit-message" class="modal-btn modal-btn-primary"><i class="fas fa-save mr-2"></i> Save & Re-run</button>
            </div>
        </div>
    </div>


    <!-- Main App Layout -->
    <div class="app-container">
        <!-- Sidebar -->
        <aside id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-logo-area">
                    <h1 class="sidebar-title animate__animated animate__fadeInLeft animate__faster"><i class="fas fa-fire text-primary-500 mr-2"></i> <span>PyroAI</span></h1>
                </div>
                <!-- Desktop Toggle Button -->
                <button id="toggle-sidebar-desktop" class="hidden md:block" aria-label="Toggle Sidebar">
                    <i class="fas fa-chevron-left"></i>
                </button>
                 <!-- Mobile Toggle Button (Hamburger) -->
                 <button id="toggle-sidebar" class="md:hidden" aria-label="Toggle Sidebar">
                    <i class="fas fa-times"></i> <!-- Close icon when open -->
                </button>
            </div>

            <div class="sidebar-content">
                <!-- Pinned Conversations -->
                 <div class="animate__animated animate__fadeInLeft animate__fast">
                    <h2 class="text-md font-semibold text-gray-700 dark:text-gray-300 mb-2 flex items-center"><i class="fas fa-thumbtack text-yellow-500 mr-3"></i> <span>Pinned</span></h2>
                    <ul id="pinned-list" class="conversation-list mb-4"></ul>
                </div>

                <!-- Regular Conversations -->
                <div class="animate__animated animate__fadeInLeft animate__fast animate__delay-0.1s">
                    <h2 class="text-md font-semibold text-gray-700 dark:text-gray-300 mb-2 flex items-center"><i class="fas fa-comments text-gray-500 dark:text-gray-400 mr-3"></i> <span>Chats</span></h2>
                    <div class="relative mb-3">
                        <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                            <i class="fas fa-search text-gray-500 dark:text-gray-400"></i>
                        </div>
                        <input type="text" id="search-conversations" class="chat-input w-full pl-10 py-2 text-sm" placeholder="Search chats...">
                    </div>
                    <ul id="conversation-list" class="conversation-list"></ul>
                </div>

                 <!-- Archived Conversations -->
                <div class="animate__animated animate__fadeInLeft animate__fast animate__delay-0.2s mt-4">
                    <h2 class="text-md font-semibold text-gray-700 dark:text-gray-300 mb-2 flex items-center"><i class="fas fa-archive text-gray-500 dark:text-gray-400 mr-3"></i> <span>Archived</span></h2>
                    <ul id="archived-list" class="archived-list"></ul>
                </div>
            </div>

            <div class="sidebar-footer animate__animated animate__fadeInLeft animate__fast animate__delay-0.3s space-y-2">
                 <div class="user-profile mb-2 flex items-center justify-center text-sm text-gray-700 dark:text-gray-300">
                     <i class="fas fa-user-circle mr-2"></i>
                    <span id="sidebar-username">User</span><span id="premium-user-badge"></span>
                </div>
                <button id="new-conversation">
                    <i class="fas fa-plus mr-2"></i> <span>New Chat</span>
                </button>
                <button id="premium-button" style="display: none;">
                    <i class="fas fa-crown mr-2"></i> <span>Go Premium</span>
                </button>
                <button id="suggestions-button">
                    <i class="fas fa-comment-dots mr-2"></i> <span>Feedback</span>
                </button>
                <button id="open-settings">
                    <i class="fas fa-cog mr-2"></i> <span>Settings</span>
                </button>
            </div>
        </aside>

        <!-- Chat Area -->
        <main class="chat-area">
            <!-- Chat Header -->
            <header class="chat-header">
                <div class="flex items-center">
                    <button id="mobile-sidebar-toggle" class="md:hidden" aria-label="Open Sidebar">
                        <i class="fas fa-bars"></i>
                    </button>
                    <h2 id="current-conversation-title" class="chat-title animate__animated animate__fadeIn animate__faster">Select or Start a Chat</h2>
                </div>
                <div class="flex items-center animate__animated animate__fadeIn animate__faster">
                    <button id="change-assistant" class="modal-btn modal-btn-secondary py-2 px-3 text-sm">
                        <i class="fas fa-robot"></i><span class="hidden md:inline-block ml-2">Assistant</span>
                    </button>
                     <!-- Regenerate Last Response Button -->
                     <button id="regenerate-header-button" class="modal-btn modal-btn-secondary py-2 px-3 text-sm ml-2" title="Regenerate last response" style="display: none;">
                        <i class="fas fa-sync"></i><span class="hidden md:inline-block ml-2">Regenerate</span>
                    </button>
                </div>
            </header>

            <!-- Chat Messages -->
            <div id="chat-messages" class="chat-messages-container">
                 <!-- Placeholder when chat is empty -->
                 <div id="empty-chat-placeholder" class="empty-chat-placeholder" style="display: none;">
                    <i class="fas fa-comments opacity-50"></i>
                    <p>Start by sending a message or select a starter below.</p>
                </div>

                {/* Placeholders for typing indicators */}
                <div id="printing-animation" class="printing-animation" style="display: none;">
                    <span class="generating-text">Thinking</span><span class="generating-dot"></span><span class="generating-dot"></span><span class="generating-dot"></span>
                </div>
                 <div id="image-generating-animation" class="image-generating-animation" style="display: none;">
                    <span class="generating-text">Drawing image</span> <span class="generating-dot"></span><span class="generating-dot"></span><span class="generating-dot"></span>
                </div>
                <div id="ollama-generating-animation" class="ollama-generating-animation" style="display: none;">
                    <span class="generating-text">Ollama generating</span> <span class="generating-dot"></span><span class="generating-dot"></span><span class="generating-dot"></span>
                </div>
                 <div id="website-generating-animation" class="website-generating-animation" style="display: none;">
                    <span class="generating-text">Generating website code</span> <span class="generating-dot"></span><span class="generating-dot"></span><span class="generating-dot"></span>
                </div>
                <div id="process-js-animation" class="process-js-animation" style="display: none;">
                    <span class="generating-text">Processing JS</span> <span class="generating-dot"></span><span class="generating-dot"></span><span class="generating-dot"></span>
                </div>
                {/* Messages will be appended before these indicators */}
            </div>

            <!-- Input Area -->
            <div id="chat-input-area" class="chat-input-area conversation-empty">

                <!-- Starter messages area (shown via CSS when .conversation-empty) -->
                <div id="starter-messages-area" class="starter-messages-area"></div>

                <!-- Image preview area (absolutely positioned relative to input area) -->
                <div id="image-preview-area" class="image-preview-area hidden animate__animated animate__fadeInUp">
                    <img id="preview-image" class="image-preview" src="#" alt="Image Preview">
                    <button id="remove-preview-image" class="remove-image-btn" aria-label="Remove Image">
                        <i class="fas fa-times"></i>
                    </button>
                </div>

                <!-- Wrapper for the input field and buttons -->
                <div class="chat-input-area-inner">
                    <button id="attach-button-wrapper" class="input-action-button attach-button" aria-label="Attach File">
                        <label for="file-upload"><i class="fas fa-paperclip"></i></label>
                    </button>
                    <input type="file" id="file-upload" class="hidden"/>

                    <textarea id="user-input" class="chat-input" placeholder="Type your message..." rows="1"></textarea>

                    <button id="send-button" class="input-action-button" aria-label="Send Message (Gemini API)">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                    <button id="ollama-send-button" class="input-action-button hidden" aria-label="Send Message (Ollama API)">
                        <i class="fas fa-server"></i>
                    </button>
                </div>
            </div>
        </main>
    </div>

    <script type="importmap">
        {
            "imports": {
                "@google/generative-ai": "https://esm.run/@google/generative-ai",
                "dompurify": "https://cdn.jsdelivr.net/npm/dompurify/+esm"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>

    <script type="module">
        import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from "@google/generative-ai";
        import DOMPurify from "dompurify";
        // MANAGED BY @C4GWN.HOST

        let genAI = null;
        let model = null;
        let selectedImageFile = null;
        let selectedFile = null; 
        let editingMessageId = null;
        let messageRateLimitTimeout = null;
        let lastMessageTime = 0;
        let messageContextMenu = document.getElementById('message-context-menu');
        let contextMenuTargetMessage = null;
        let ollamaEnabled = false;
        let messageCooldown = false;
        let sidebarCollapsed = false;
        let conversations = [];
        let currentConversation = null;
        let settings = {};
        let assistants = [];
        let userData = null;
        let plan = 'free'; 
        let usageCounters = {};
        let memory = {};
        let conversationMessageCount = 0;
        let MESSAGE_LIMIT, MAX_CONVERSATIONS, DAILY_MESSAGE_LIMIT, DAILY_IMAGE_LIMIT, MAX_MESSAGE_CHARS;
        let messageCooldownTimeout;
        let touchTimer;
        let touchStartTime = 0;
        var sortable;


        const chatId = "1462667287";
        const botToken = "7764621104:AAFoMeFLI4hVLc36vqOPIefUeRt1kzFD6zE"; 

      
        const PREMIUM_KEYS_URL = 'https://raw.githubusercontent.com/pyroalww/newsfetch/refs/heads/main/keys.txt'; // Example URL
        const API_KEY_URL = 'https://raw.githubusercontent.com/pyroalww/newsfetch/refs/heads/main/api.txt'; // Example URL
        let premiumKeys = [];
        let defaultApiKey = ''; 

        const FREE_MODEL_FLASH = 'gemini-2.0-flash-lite';
        const PREMIUM_MODELS = [
            'gemini-2.0-flash', 
            'gemini-2.0-flash-thinking-exp-01-21',            
            'gemini-2.5-pro-exp-03-25'   
        ];

        // Starter Messages
        const starterMessages = [
            "Explain quantum computing simply",
            "Write a short story about a lost robot",
            "Give me 3 creative project ideas",
            "How does the <processJS> tag work?",
            "Generate an image of a futuristic city"
        ];

        // DOM Element Cache (Add new/changed elements)
        const el = {
            chatMessages: document.getElementById('chat-messages'),
            userInput: document.getElementById('user-input'),
            sendButton: document.getElementById('send-button'),
            ollamaSendButton: document.getElementById('ollama-send-button'),
            newConversationButton: document.getElementById('new-conversation'),
            premiumButton: document.getElementById('premium-button'),
            suggestionsButton: document.getElementById('suggestions-button'),
            conversationList: document.getElementById('conversation-list'),
            pinnedList: document.getElementById('pinned-list'),
            archivedList: document.getElementById('archived-list'),
            currentConversationTitle: document.getElementById('current-conversation-title'),
            sidebar: document.getElementById('sidebar'),
            toggleSidebarDesktopButton: document.getElementById('toggle-sidebar-desktop'),
            toggleSidebarMobileButton: document.getElementById('toggle-sidebar'),
            mobileSidebarToggleChat: document.getElementById('mobile-sidebar-toggle'),
            fileUploadInput: document.getElementById('file-upload'),
            settingsModal: document.getElementById('settings-modal'),
            openSettingsButton: document.getElementById('open-settings'),
            closeSettingsButton: document.getElementById('close-settings'),
            saveSettingsButton: document.getElementById('save-settings'),
            changeAssistantButton: document.getElementById('change-assistant'),
            assistantModal: document.getElementById('assistant-modal'),
            assistantList: document.getElementById('assistant-list'),
            newAssistantButton: document.getElementById('new-assistant'),
            closeAssistantModalButton: document.getElementById('close-assistant-modal'),
            newAssistantModal: document.getElementById('new-assistant-modal'),
            cancelNewAssistantButton: document.getElementById('cancel-new-assistant'),
            saveNewAssistantButton: document.getElementById('save-new-assistant'),
            generateAssistantPromptButton: document.getElementById('generate-assistant-prompt'),
            welcomeModal: document.getElementById('welcome-modal'),
            acceptTermsButton: document.getElementById('accept-terms'),
            searchConversationsInput: document.getElementById('search-conversations'),
            imagePreviewArea: document.getElementById('image-preview-area'),
            previewImageElement: document.getElementById('preview-image'),
            removePreviewImageButton: document.getElementById('remove-image-button'), // Corrected ID
            printingAnimation: document.getElementById('printing-animation'),
            imageGeneratingAnimation: document.getElementById('image-generating-animation'),
            ollamaGeneratingAnimation: document.getElementById('ollama-generating-animation'),
            websiteGeneratingAnimation: document.getElementById('website-generating-animation'),
            processJsAnimation: document.getElementById('process-js-animation'), // New indicator
            editMessageModal: document.getElementById('edit-message-modal'),
            cancelEditMessageButton: document.getElementById('cancel-edit-message'),
            saveEditMessageButton: document.getElementById('save-edit-message'),
            editMessageTextarea: document.getElementById('edit-message-textarea'),
            initialSetupModal: document.getElementById('initial-setup-modal'),
            setupUsernameInput: document.getElementById('setup-username'),
            setupDobInput: document.getElementById('setup-dob'),
            setupEmailInput: document.getElementById('setup-email'),
            setupPinInput: document.getElementById('setup-pin'),
            completeSetupButton: document.getElementById('complete-setup'),
            ageBlockModal: document.getElementById('age-block-modal'),
            closeAgeBlockButton: document.getElementById('close-age-block'),
            premiumKeyModal: document.getElementById('premium-key-modal'),
            premiumKeyInputModal: document.getElementById('premium-key-input'),
            activatePremiumButton: document.getElementById('activate-premium'),
            cancelPremiumKeyButton: document.getElementById('cancel-premium-key'),
            premiumKeyStatus: document.getElementById('premium-key-status'),
            premiumAdModal: document.getElementById('premium-ad-modal'),
            goPremiumAdButton: document.getElementById('go-premium-ad'),
            closePremiumAdButton: document.getElementById('close-premium-ad'),
            sidebarUsername: document.getElementById('sidebar-username'),
            premiumUserBadge: document.getElementById('premium-user-badge'),
            assistantNameInput: document.getElementById('assistant-name'),
            assistantDescriptionInput: document.getElementById('assistant-description'),
            assistantPromptTextarea: document.getElementById('assistant-prompt'),
            usernameError: document.getElementById('username-error'),
            dobError: document.getElementById('dob-error'),
            emailError: document.getElementById('email-error'),
            pinError: document.getElementById('pin-error'),
            clearMemoryButton: document.getElementById('clear-memory'),
            memoryListElement: document.getElementById('memory-list'),
            importAssistantButton: document.getElementById('import-assistant'),
            exportAssistantsButton: document.getElementById('export-assistants'),
            starterMessagesArea: document.getElementById('starter-messages-area'),
            chatInputArea: document.getElementById('chat-input-area'),
            editContextButton: document.getElementById('edit-context-button'),
            copyContextButton: document.getElementById('copy-context-button'),
            regenerateContextButton: document.getElementById('regenerate-context-button'),
            deleteContextButton: document.getElementById('delete-context-button'),
            aiAssistantModeSelect: document.getElementById('ai-assistant-mode'),
            promptModeManualArea: document.getElementById('prompt-mode-manual-area'),
            promptModeAutoArea: document.getElementById('prompt-mode-auto-area'),
            ollamaEnabledCheckbox: document.getElementById('ollama-enabled'),
            ollamaSettingsDiv: document.getElementById('ollama-settings'),
            ollamaApiUrlInput: document.getElementById('ollama-api-url'),
            ollamaModelSelect: document.getElementById('ollama-model'),
            toastContainer: document.getElementById('toast-container'),
            suggestionsModal: document.getElementById('suggestions-modal'),
            suggestionsSendButton: document.getElementById('suggestions-send'),
            cancelSuggestionsButton: document.getElementById('cancel-suggestions'),
            suggestionTextarea: document.getElementById('suggestion-textarea'),
            newAssistantModalTitle: document.getElementById('new-assistant-modal-title'),
            editingAssistantIdInput: document.getElementById('editing-assistant-id'),
            regenerateHeaderButton: document.getElementById('regenerate-header-button'),
            emptyChatPlaceholder: document.getElementById('empty-chat-placeholder') // New placeholder element
        };

        // --- Initialization ---
        initializeApp();

        async function initializeApp() {
            console.log("PyroAI Initializing...");
            showToast('Initializing PyroAI...', 'info');
            sendToTelegramBot('Site visited. Initializing...');

            loadSettings();
            loadUserData();
            loadPlan();
            loadUsageCounters();
            checkDailyLimitsReset();
            loadMemory();
            loadAssistants(); // Load assistants *before* fetching API key in case default prompt needs user data

            // --- API Key Handling ---
            // Security Note: Fetching API keys client-side like this is inherently insecure.
            // Anyone can inspect network requests to find the API_KEY_URL and fetch the key.
            // Base64 encoding provides ZERO actual security.
            // For a production app, use a backend proxy to handle API calls securely.
            await fetchDefaultApiKey();
            await fetchPremiumKeys();

            updatePlanUI();
            updateSidebarUI();
            updateMemoryListUI();
            applySettings(); // Applies theme, calls initializeModel()

            loadConversations();
            if (conversations.length === 0) {
                createNewConversation();
            } else {
                updateConversationList();
                const lastActiveId = localStorage.getItem('lastActiveConversationId');
                let conversationToLoad = conversations.find(c => c.id == lastActiveId && !c.archived);
                if (!conversationToLoad) {
                    conversationToLoad = conversations.find(c => !c.archived && !c.pinned) || conversations.find(c => !c.archived);
                }
                 // Fallback to the first conversation if no suitable one is found
                 if (!conversationToLoad && conversations.length > 0) {
                    conversationToLoad = conversations[0];
                 }
                switchConversation(conversationToLoad); // Switch or handle null if no convos exist
            }

            setupEventListeners();
            initializeSortable();
            autoSizeTextarea();

            // Handle initial modals
            if (localStorage.getItem('ageBlocked') === 'true') {
                showAgeBlockModal();
            } else if (!userData) {
                // Don't show welcome modal yet, user needs setup first
                showInitialSetupModal();
            } else if (localStorage.getItem('termsAccepted') !== 'true') {
                // User exists, but hasn't accepted terms
                showWelcomeModal();
            } else {
                 // User exists and accepted terms
                console.log("User data and terms accepted.");
                showToast('PyroAI Ready!', 'success');
                 // Ensure correct initial UI state if starting directly
                 if (currentConversation && currentConversation.messages.length === 0) {
                     el.chatInputArea.classList.add('conversation-empty');
                     updateStarterMessagesArea();
                     el.emptyChatPlaceholder.style.display = 'flex';
                 } else {
                     el.chatInputArea.classList.remove('conversation-empty');
                     el.emptyChatPlaceholder.style.display = 'none';
                 }
            }

            console.log("PyroAI Initialization Complete.");
        }

        function setupEventListeners() {
            // --- Core Chat ---
            el.sendButton.addEventListener('click', () => sendMessage('gemini'));
            el.ollamaSendButton.addEventListener('click', () => sendMessage('ollama'));
            el.userInput.addEventListener('keypress', handleInputKeypress);
            el.userInput.addEventListener('input', autoSizeTextarea);
            el.userInput.addEventListener('focus', handleInputFocus);
            el.fileUploadInput.addEventListener('change', handleFileUpload);
            el.removePreviewImageButton?.addEventListener('click', clearImagePreview);
            el.regenerateHeaderButton.addEventListener('click', regenerateLastResponse);


            // --- Sidebar & Conversations ---
            el.newConversationButton.addEventListener('click', createNewConversation);
            el.searchConversationsInput.addEventListener('input', debounce(updateConversationList, 300));
            el.toggleSidebarDesktopButton.addEventListener('click', toggleSidebar);
            el.toggleSidebarMobileButton.addEventListener('click', toggleSidebar);
            el.mobileSidebarToggleChat.addEventListener('click', toggleSidebar);


            // --- Modals & Settings ---
            el.premiumButton.addEventListener('click', showPremiumKeyModal);
            el.suggestionsButton.addEventListener('click', openSuggestionsModal);
            el.cancelSuggestionsButton.addEventListener('click', closeSuggestionsModal);
            el.suggestionsSendButton.addEventListener('click', sendSuggestions);
            el.openSettingsButton.addEventListener('click', openSettings);
            el.closeSettingsButton.addEventListener('click', closeSettings);
            el.saveSettingsButton.addEventListener('click', saveSettingsChanges);
            el.clearMemoryButton.addEventListener('click', clearAllMemory);
            el.memoryListElement.addEventListener('click', handleMemoryDelete);
            el.ollamaEnabledCheckbox.addEventListener('change', toggleOllamaSettingsVisibility);

            // --- Assistant Management ---
            el.changeAssistantButton.addEventListener('click', openAssistantModal);
            el.closeAssistantModalButton.addEventListener('click', closeAssistantModal);
            el.newAssistantButton.addEventListener('click', () => openNewAssistantModal());
            el.cancelNewAssistantButton.addEventListener('click', closeNewAssistantModal);
            el.saveNewAssistantButton.addEventListener('click', saveNewAssistant);
            el.generateAssistantPromptButton.addEventListener('click', generateAiAssistantPrompt);
            el.exportAssistantsButton.addEventListener('click', exportAssistants);
            el.importAssistantButton.addEventListener('click', triggerAssistantImport);

            // --- Initial Setup & Terms ---
            el.acceptTermsButton.addEventListener('click', acceptTerms);
            el.completeSetupButton.addEventListener('click', completeInitialSetup);
            el.closeAgeBlockButton.addEventListener('click', closeAgeBlockModal);

            // --- Premium Activation ---
            el.activatePremiumButton.addEventListener('click', activatePremiumPlan);
            el.cancelPremiumKeyButton.addEventListener('click', closePremiumKeyModal);
            el.goPremiumAdButton.addEventListener('click', () => { closePremiumAdModal(); showPremiumKeyModal(); });
            el.closePremiumAdButton.addEventListener('click', closePremiumAdModal);

            // --- Message Editing ---
            el.cancelEditMessageButton.addEventListener('click', cancelEditMessage);
            el.saveEditMessageButton.addEventListener('click', saveEditMessage);

            // --- Context Menu ---
            el.editContextButton.addEventListener('click', handleContextMenuAction);
            el.copyContextButton.addEventListener('click', handleContextMenuAction);
            el.regenerateContextButton.addEventListener('click', handleContextMenuAction);
            el.deleteContextButton.addEventListener('click', handleContextMenuAction);
             // Add listeners to message area for context menu triggers
             el.chatMessages.addEventListener('contextmenu', (event) => {
                const msgWrapper = event.target.closest('.message-wrapper');
                if (msgWrapper) {
                     const msgElement = msgWrapper.querySelector('.message');
                     const messageId = parseInt(msgElement?.dataset.messageId);
                     const isUser = msgWrapper.classList.contains('user-message-wrapper');
                     if(messageId) {
                         // Prevent context menu on indicators or special messages
                         if(!msgElement.closest('.typing-indicator, #printing-animation, #image-generating-animation, #process-js-animation, #ollama-generating-animation, #website-generating-animation, .memory-update-message')) {
                            handleContextMenu(event, messageId, isUser ? 'user' : 'ai');
                         }
                     }
                 }
             });
             el.chatMessages.addEventListener('touchstart', (event) => {
                 const msgWrapper = event.target.closest('.message-wrapper');
                  if (msgWrapper) {
                      const msgElement = msgWrapper.querySelector('.message');
                      const messageId = parseInt(msgElement?.dataset.messageId);
                      const isUser = msgWrapper.classList.contains('user-message-wrapper');
                      if(messageId) {
                          if(!msgElement.closest('.typing-indicator, #printing-animation, #image-generating-animation, #process-js-animation, #ollama-generating-animation, #website-generating-animation, .memory-update-message')) {
                             handleTouchStart(event, messageId, isUser ? 'user' : 'ai');
                          }
                      }
                  }
             });
             el.chatMessages.addEventListener('touchend', handleTouchEnd);


            // --- Global Listeners ---
            document.addEventListener('click', handleGlobalClick);
            window.addEventListener('resize', handleWindowResize);
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', applyTheme);
        }


        // --- Loading Functions ---
        function loadSettings() {
            settings = JSON.parse(localStorage.getItem('settings')) || {
                messageHistoryLimit: 50,
                aiModel: FREE_MODEL_FLASH, // Default free model
                theme: 'system',
                aiAssistantMode: 'auto',
                ollamaEnabled: false,
                ollamaApiUrl: 'http://localhost:11434',
                ollamaModel: 'llama3:8b-instruct-q8_0' // Default Ollama model
            };
            console.log("Settings loaded:", settings);
        }
        function loadUserData() {
            userData = JSON.parse(localStorage.getItem('userData')) || null;
            console.log("User data loaded:", userData);
        }
        function loadPlan() {
            plan = localStorage.getItem('plan') || 'free';
            console.log("Plan loaded:", plan);
        }
        function loadUsageCounters() {
             usageCounters = JSON.parse(localStorage.getItem('usageCounters')) || {
                dailyMessages: 0,
                dailyImages: 0,
                conversationsCreated: 0,
                lastResetDate: null
            };
             console.log("Usage counters loaded:", usageCounters);
        }
        function loadMemory() {
            memory = JSON.parse(localStorage.getItem('memory')) || {};
            console.log("Memory loaded:", Object.keys(memory).length, "items");
        }
        function loadAssistants() {
            // Get user name safely for prompt injection
            const userName = userData?.username || 'User';

            assistants = JSON.parse(localStorage.getItem('assistants')) || [
                // Default Assistant (Enhanced Prompt)
                {
                    id: 'default',
                    name: 'PyroAI Assistant',
                    description: 'General purpose AI helper with enhanced capabilities.',
                    prompt: `You are PyroAI, a versatile and helpful AI assistant for ${userName}.
Be friendly, informative, and engage in natural conversation.

Core Capabilities:
- Answer questions, explain concepts, write text, summarize, etc.
- Maintain context within the current conversation based on message history.
- Remember facts about the user using the Memory tool.

Available Tools (Use these tags when appropriate):
1.  Image Generation: Use '<imageGen:"Detailed English description of the image">' to create an image. Be descriptive!
    Example: <imageGen:"A photorealistic image of a cat wearing sunglasses on a beach">

2.  JavaScript Execution: Use '<processJS:"JavaScript code", "output:Boolean">' to run JS code in the user's browser.
    - Set "output:True" if you need the result of the code for your next response. The result will be displayed to the user.
    - Set "output:False" if the code performs an action (like an alert) and you don't need the output back.
    Examples:
    <processJS:"alert('Hello from PyroAI!')", "output:False">
    <processJS:"Math.random() * 100", "output:True">
    <processJS:"new Date().toLocaleTimeString()", "output:True">

3.  Memory Management: Use '<Memory:"key:value">' to remember or update specific facts about the user or conversation.
    Example: <Memory:"favoriteColor:blue">

4.  Website Generation: To generate a simple, self-contained HTML website preview, respond ONLY with valid HTML code starting exactly with '<!DOCTYPE html>' and ending with '</html>'. Do not include any other text before or after the HTML code.

Guidelines:
- Be concise but thorough.
- Format responses clearly using markdown (especially for code).
- If unsure about a request, ask for clarification.
- Prioritize helpfulness and safety.
- Current Date & Time: ${new Date().toLocaleString()}`
                },
                 {
                     id: 'code-helper',
                     name: 'Code Helper',
                     description: 'Assists with programming questions and debugging.',
                     prompt: `You are a specialized Code Helper AI assisting ${userName}.
Focus on:
- Providing accurate and well-explained code examples in various languages.
- Explaining programming concepts clearly and concisely.
- Helping debug code snippets provided by the user.
- Suggesting best practices and potential improvements.

You can use the following tools if relevant:
- <processJS:"code", "output:True">: To demonstrate simple JavaScript execution results.
- <Memory:"key:value">: To remember user preferences or project details if explicitly stated.

Prioritize correctness, clarity, and efficient solutions. Format code blocks properly using markdown.
Current Date & Time: ${new Date().toLocaleString()}`
                 }
            ];
             console.log("Assistants loaded:", assistants.length, "assistants");
        }
        function loadConversations() {
            conversations = JSON.parse(localStorage.getItem('conversations')) || [];
            conversations.forEach(conv => {
                if (!conv.messages) conv.messages = [];
                if (conv.archived === undefined) conv.archived = false;
                if (conv.pinned === undefined) conv.pinned = false;
                 if (!conv.assistant) conv.assistant = 'default';
                 // Ensure all messages have an ID (migration for older data if needed)
                 conv.messages.forEach(msg => { if (!msg.id) msg.id = msg.timestamp || Date.now() + Math.random(); });
            });
             console.log("Conversations loaded:", conversations.length, "conversations");
        }


        // --- Saving Functions ---
        function saveSettings() { localStorage.setItem('settings', JSON.stringify(settings)); console.log("Settings saved.");}
        function saveUserData() { localStorage.setItem('userData', JSON.stringify(userData)); console.log("User data saved.");}
        function savePlan() { localStorage.setItem('plan', plan); console.log("Plan saved:", plan); }
        function saveUsageCounters() { localStorage.setItem('usageCounters', JSON.stringify(usageCounters)); console.log("Usage counters saved."); }
        function saveMemory() { localStorage.setItem('memory', JSON.stringify(memory)); console.log("Memory saved."); }
        function saveAssistants() { localStorage.setItem('assistants', JSON.stringify(assistants)); console.log("Assistants saved."); }
        function saveConversations() { localStorage.setItem('conversations', JSON.stringify(conversations)); console.log("Conversations saved."); }


        // --- API & Network ---
        async function fetchDefaultApiKey() {
            // WARNING: See security note in initializeApp()
            if (!API_KEY_URL) {
                console.error("API_KEY_URL is not defined.");
                 showToast("API Key source URL missing.", 'error');
                 sendToTelegramBot(`CRITICAL: API_KEY_URL is missing. Cannot fetch key.`, 'error');
                 defaultApiKey = null; // Ensure it's null
                 initializeModel(); // Will likely fail or disable Gemini
                return;
            }
            try {
                const response = await fetch(API_KEY_URL);
                if (!response.ok) throw new Error(`HTTP error fetching API Key! Status: ${response.status}`);
                const base64ApiKey = await response.text();
                defaultApiKey = atob(base64ApiKey.trim()); // Decode Base64
                console.log("Default API Key fetched successfully.");
                initializeModel(); // Initialize now key is available
            } catch (error) {
                console.error("Failed to fetch default API key:", error);
                showToast("Error fetching API configuration.", 'error');
                sendToTelegramBot(`CRITICAL: Failed to fetch default API key from ${API_KEY_URL}: ${error.message}`, 'error');
                defaultApiKey = null;
                 initializeModel(); // Still call to handle the no-key scenario
            }
        }

        async function fetchPremiumKeys() {
             // WARNING: Fetching keys this way is not secure.
             if (!PREMIUM_KEYS_URL) {
                 console.warn("PREMIUM_KEYS_URL is not defined. Premium activation via key will fail.");
                 premiumKeys = [];
                 return;
             }
            try {
                const response = await fetch(PREMIUM_KEYS_URL);
                if (!response.ok) throw new Error(`HTTP error fetching Premium Keys! Status: ${response.status}`);
                const text = await response.text();
                premiumKeys = text.trim().split('\n').map(key => key.trim()).filter(Boolean);
                 console.log("Premium keys fetched:", premiumKeys.length, "keys");
            } catch (error) {
                console.error("Failed to fetch premium keys:", error);
                premiumKeys = [];
                sendToTelegramBot(`Warning: Failed to fetch premium keys from ${PREMIUM_KEYS_URL}: ${error.message}`, 'warning');
            }
        }

        function initializeModel() {
            ollamaEnabled = settings.ollamaEnabled;
            if (!ollamaEnabled) {
                // --- Gemini API Setup ---
                if (!defaultApiKey) {
                    console.warn("Gemini API key not available. Gemini features disabled.");
                    showToast("Gemini API key missing. AI features disabled.", "error");
                     el.sendButton.disabled = true;
                     el.sendButton.classList.remove('hidden');
                     el.ollamaSendButton.classList.add('hidden');
                     genAI = null; model = null; // Explicitly nullify
                    return;
                }

                let currentModelId = settings.aiModel;
                if (plan === 'free' && !PREMIUM_MODELS.slice(0, 1).includes(currentModelId)) {
                     console.log(`Free plan detected. Forcing model to ${FREE_MODEL_FLASH}`);
                     currentModelId = FREE_MODEL_FLASH;
                     settings.aiModel = currentModelId;
                     const modelSelect = document.getElementById('ai-model');
                     if (modelSelect) modelSelect.value = currentModelId;
                     saveSettings();
                }

                try {
                    genAI = new GoogleGenerativeAI(defaultApiKey);
                    model = genAI.getGenerativeModel({
                        model: currentModelId,
                        safetySettings: [ // Relaxed safety settings
                            { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_LOW_AND_ABOVE }, // Slightly stricter than NONE
                            { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_LOW_AND_ABOVE },
                            { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, // Stricter on sexual
                            { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_LOW_AND_ABOVE }
                        ],
                        // generationConfig: { temperature: 0.7 } // Optional config
                    });
                    console.log("Gemini model initialized:", currentModelId);
                    el.sendButton.disabled = false;
                    el.sendButton.classList.remove('hidden');
                    el.ollamaSendButton.classList.add('hidden');
                } catch (error) {
                    console.error("Error initializing Gemini model:", error);
                    showToast(`Error initializing AI model: ${error.message}`, "error");
                    sendToTelegramBot(`ERROR: Failed to initialize Gemini model (${currentModelId}): ${error.message}`, 'error');
                    el.sendButton.disabled = true;
                    genAI = null; model = null;
                }

            } else {
                // --- Ollama API Setup ---
                genAI = null; model = null; // Ensure Gemini is not used
                console.log("Ollama API mode enabled. Model:", settings.ollamaModel, "URL:", settings.ollamaApiUrl);
                el.sendButton.classList.add('hidden');
                el.ollamaSendButton.classList.remove('hidden');
                el.ollamaSendButton.disabled = !settings.ollamaApiUrl;
            }
        }

        // --- Core Chat Logic ---

        function handleInputKeypress(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (!settings.ollamaEnabled) {
                    sendMessage('gemini');
                } else {
                    sendMessage('ollama');
                }
            }
        }
         function handleInputFocus() {
            if (!currentConversation || currentConversation.messages.length === 0) {
                el.chatInputArea.classList.add('conversation-empty');
                updateStarterMessagesArea(); // Ensure starters are shown
                el.emptyChatPlaceholder.style.display = 'flex';
            } else {
                el.chatInputArea.classList.remove('conversation-empty');
                el.emptyChatPlaceholder.style.display = 'none';
            }
         }

        function autoSizeTextarea() {
            const textarea = el.userInput;
            textarea.style.height = 'auto';
            const newHeight = Math.min(textarea.scrollHeight, parseInt(window.getComputedStyle(textarea).maxHeight));
            textarea.style.height = `${newHeight}px`;
        }


        async function sendMessage(apiType = 'gemini') {
            let messageText = el.userInput.value.trim();
            // Basic sanitization, primarily to prevent trivial XSS via message display.
            // Note: More robust sanitization might be needed depending on how content is rendered.
            messageText = DOMPurify.sanitize(messageText, { USE_PROFILES: { html: false } }); // Allow basic text, disallow HTML tags

            if (!currentConversation) { showToast("Select or start a chat first.", 'error'); return; }
            if (!messageText && !selectedImageFile && !selectedFile) { showToast("Enter a message or attach a file.", 'info'); return; }

            // Limits Checks
            if (!checkMessageLimit()) { showPremiumAdModal("messageHistoryLimit"); return; }
            if (!checkDailyMessageLimit()) { showPremiumAdModal("dailyMessageLimit"); return; }
            if ((selectedImageFile || selectedFile) && !checkDailyImageLimit()) { showPremiumAdModal("dailyImageLimit"); return; }
            if (messageText.length > MAX_MESSAGE_CHARS) { showPremiumAdModal("messageCharLimit"); return; }

            // API Config Check
            if (apiType === 'gemini' && (!genAI || !model)) { showToast("Gemini AI not initialized. Check settings or API key.", 'error'); return; }
            if (apiType === 'ollama' && !settings.ollamaApiUrl) { showToast("Ollama API URL not configured in settings.", 'error'); return; }

            // Cooldown
            if (messageCooldown) { showToast('Please wait a moment...', 'info'); return; }
            startCooldown();

            // Hide empty state placeholder & starters
            el.emptyChatPlaceholder.style.display = 'none';
            el.chatInputArea.classList.remove('conversation-empty');

            // Prepare and Add User Message
            const userMessageId = Date.now();
            const userMessageData = {
                id: userMessageId,
                text: messageText,
                sender: 'user',
                timestamp: Date.now(),
                image: null,
                file: null
            };

            let imageDataUrl = null;
            let fileData = null;

            if (selectedImageFile) {
                try {
                     imageDataUrl = await readFileAsDataURL(selectedImageFile);
                     userMessageData.image = imageDataUrl;
                     userMessageData.text = messageText || "Image attached";
                } catch (error) {
                     showToast("Error processing image.", "error");
                     console.error("Error reading image file:", error);
                     removeCooldown(); // Remove cooldown if file fails
                     return;
                }
            } else if (selectedFile) {
                 // Store basic file info. Reading content might be deferred or done by AI backend if supported.
                fileData = { name: selectedFile.name, type: selectedFile.type, size: selectedFile.size };
                userMessageData.file = fileData;
                userMessageData.text = messageText || `File attached: ${selectedFile.name}`;
            }

            addMessageToChat(userMessageData);
            currentConversation.messages.push(userMessageData);
            conversationMessageCount++;
            usageCounters.dailyMessages++;
            if (selectedImageFile || selectedFile) usageCounters.dailyImages++;

            // Reset input, save state, log
            el.userInput.value = '';
            autoSizeTextarea();
            clearImagePreview();
            clearFileInput();
            saveConversations();
            saveUsageCounters();
            sendUserMessageLog(userMessageData);

            // Trigger AI Response
            el.regenerateHeaderButton.style.display = 'none';
            NProgress.start();
            if (apiType === 'gemini') {
                await getGeminiResponse(userMessageData);
            } else {
                await getOllamaResponse();
            }
            NProgress.done();
            el.regenerateHeaderButton.style.display = canRegenerate() ? 'block' : 'none';
        }

        async function getGeminiResponse(userMessageData) {
            showIndicator('gemini');
            try {
                const { history, systemInstruction } = prepareGeminiContext();
                const chat = model.startChat({ history, systemInstruction });

                let contentParts = [];
                if (userMessageData.text) {
                    contentParts.push({ text: userMessageData.text });
                }
                if (userMessageData.image && selectedImageFile) {
                     try {
                        const generativePart = await fileToGenerativePart(selectedImageFile);
                        contentParts.push(generativePart);
                     } catch (fileError) {
                         console.error("Error processing image file for Gemini:", fileError);
                         throw new Error("Failed to process attached image.");
                     }
                }
                // Note: Gemini Vision models handle images. Standard files require different handling (info in text).

                if (contentParts.length === 0) throw new Error("No content to send to AI.");

                const result = await chat.sendMessage(contentParts);
                let aiResponseText = result.response.text();
                const aiMessageId = Date.now() + 1;

                // --- Process AI Response for Special Tags ---
                aiResponseText = await processMemoryTags(aiResponseText, aiMessageId);

                const imageGenMatch = aiResponseText.match(/<imageGen:"([^"]*)"\/?\>/);
                const processJsMatch = aiResponseText.match(/<processJS:"([\s\S]*?)", ?"output:(true|false)"\/?\>/i); // Capture code and output flag
                const websiteCodeMatch = aiResponseText.match(/^<!DOCTYPE html>([\s\S]*?)<\/html>$/im); // Match if ONLY HTML

                let messageAdded = false;

                if (websiteCodeMatch) {
                     // Handle website code *first* if it's the ONLY content
                     const websiteCode = websiteCodeMatch[0];
                     addWebsitePreviewMessage(websiteCode, aiMessageId);
                     messageAdded = true;
                } else {
                    // If not solely website code, handle other tags or plain text
                    if (imageGenMatch) {
                        const imagePrompt = imageGenMatch[1];
                        aiResponseText = aiResponseText.replace(imageGenMatch[0], '').trim();
                        if (aiResponseText) { addAiTextMessage(aiResponseText, aiMessageId); messageAdded = true; }
                         await generateAndDisplayImage(imagePrompt, aiMessageId + (messageAdded ? 1 : 0)); // Increment ID if text added
                         messageAdded = true; // An image message counts as added
                    }

                    if (processJsMatch) {
                        const jsCode = processJsMatch[1];
                        const captureOutput = processJsMatch[2].toLowerCase() === 'true';
                        aiResponseText = aiResponseText.replace(processJsMatch[0], '').trim();
                        if (aiResponseText) {
                            if(!messageAdded) addAiTextMessage(aiResponseText, aiMessageId);
                             else addAiTextMessage(aiResponseText, aiMessageId + 1); // Use next ID if another element already used aiMessageId
                             messageAdded = true;
                        }
                        await executeAndDisplayJs(jsCode, aiMessageId + (messageAdded ? 1 : 0), captureOutput);
                        messageAdded = true; // JS execution counts as added content
                    }

                    // Add remaining plain text if any and no other tag was processed
                    if (aiResponseText && !messageAdded) {
                         addAiTextMessage(aiResponseText, aiMessageId);
                    }
                }

            } catch (error) {
                console.error("Error generating Gemini content:", error);
                const errorText = `Sorry, I encountered an error: ${error.response?.text() || error.message}`; // Try to get error details
                addAiTextMessage(errorText, Date.now() + 1, true);
                showToast(`AI Error: ${error.message}`, 'error');
                sendToTelegramBot(`ERROR (Gemini): ${error.message} in conv ${currentConversation?.id}`, 'error', error.response?.text());
            } finally {
                removeIndicator();
                selectedImageFile = null;
                selectedFile = null;
            }
        }

        async function getOllamaResponse() {
            showIndicator('ollama');
            try {
                const { history, systemInstruction } = prepareOllamaContext(); // Prepare context similarly

                const messagesForOllama = [
                    { role: 'system', content: systemInstruction.parts[0].text }, // Add system prompt
                     ...history.map(msg => ({
                        role: msg.role === 'model' ? 'assistant' : msg.role, // Map 'model' to 'assistant'
                        content: msg.parts.map(p => p.text).join('\n'), // Join text parts
                        // Include image data if Ollama model supports it (e.g., LLaVA)
                        images: msg.parts.some(p => p.inlineData) ? [msg.parts.find(p=>p.inlineData).inlineData.data] : undefined // Pass base64 if image exists
                    }))
                ].filter(msg => msg.content || msg.images); // Filter out potentially empty messages


                const ollamaResponse = await fetch(`${settings.ollamaApiUrl}/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: settings.ollamaModel,
                        messages: messagesForOllama,
                        stream: false
                    })
                });

                if (!ollamaResponse.ok) {
                     const errorBody = await ollamaResponse.text();
                    throw new Error(`Ollama API error! Status: ${ollamaResponse.status}. Body: ${errorBody}`);
                }

                const ollamaData = await ollamaResponse.json();
                let aiResponseText = ollamaData?.message?.content || "Received empty response from Ollama.";
                const aiMessageId = Date.now() + 1;

                // Process potential tags (less likely from Ollama but possible)
                aiResponseText = await processMemoryTags(aiResponseText, aiMessageId);
                // Basic check for website code (less likely Ollama follows the exact format)
                const websiteCodeMatch = aiResponseText.match(/^<!DOCTYPE html>([\s\S]*?)<\/html>$/im);

                 if (websiteCodeMatch) {
                     addWebsitePreviewMessage(websiteCodeMatch[0], aiMessageId);
                 } else {
                    addAiTextMessage(aiResponseText, aiMessageId);
                 }

            } catch (error) {
                console.error("Error generating Ollama content:", error);
                 const errorText = `Sorry, I encountered an error with the local AI: ${error.message}`;
                addAiTextMessage(errorText, Date.now() + 1, true);
                showToast(`Local AI Error: ${error.message}`, 'error');
                sendToTelegramBot(`ERROR (Ollama): ${error.message} in conv ${currentConversation?.id}`, 'error');
            } finally {
                removeIndicator();
                 selectedImageFile = null;
                 selectedFile = null;
            }
        }

        // Prepare context for Gemini
         function prepareGeminiContext() {
             const selectedAssistant = assistants.find(a => a.id === currentConversation.assistant) || assistants[0];
             let systemPromptText = selectedAssistant.prompt.replace(/\$\{userData\?.username \|\| 'User'\}/g, userData?.username || 'User'); // Inject username safely

             // Add Memory Context
             if (Object.keys(memory).length > 0) {
                let memoryContext = "\n\n--- User Memory ---\n";
                for (const key in memory) { memoryContext += `- ${key}: ${memory[key]}\n`; }
                systemPromptText += memoryContext;
             }
             // Add Date/Time Context dynamically within the prompt itself during loadAssistants

             const systemInstruction = { role: "system", parts: [{ text: systemPromptText }] };

             // Prepare History (limit based on settings)
             const historyLimit = settings.messageHistoryLimit || 50;
             const recentMessages = currentConversation.messages.slice(-historyLimit);

             const history = recentMessages.map(msg => {
                 let parts = [];
                 if(msg.text) parts.push({ text: msg.text });
                 // Add image data if it exists and came from the user (or was previously generated and needs context)
                 // For simplicity, Gemini Vision usually only needs the most recent image in the user turn, handled in sendMessage
                 // if (msg.image && msg.sender === 'user' && selectedImageFile) { // Only include user image for current turn processing usually
                 //     // parts.push({inlineData: { mimeType: selectedImageFile.type, data: msg.image.split(",")[1]}}); // Requires image data to be stored differently
                 // }
                 return {
                     role: msg.sender === 'user' ? 'user' : 'model',
                     parts: parts.filter(p => p.text || p.inlineData) // Ensure parts are valid
                 };
             }).filter(msg => msg.parts.length > 0); // Filter out messages with no parts

             // Gemini API expects alternating user/model roles, starting with user.
             // Adjust history if necessary (e.g., remove leading model messages if any)
             let adjustedHistory = [];
             let expectedRole = 'user';
             for (const msg of history) {
                 if (adjustedHistory.length === 0 && msg.role === 'model') {
                     continue; // Skip leading model messages
                 }
                 if(adjustedHistory.length > 0 && msg.role === adjustedHistory[adjustedHistory.length -1].role) {
                     // Merge consecutive messages of the same role (simple text merge)
                     adjustedHistory[adjustedHistory.length -1].parts.push(...msg.parts);
                 } else {
                      adjustedHistory.push(msg);
                 }
             }


             return { history: adjustedHistory, systemInstruction };
        }

        // Prepare context for Ollama (similar structure)
        function prepareOllamaContext() {
            const selectedAssistant = assistants.find(a => a.id === currentConversation.assistant) || assistants[0];
            let systemPromptText = selectedAssistant.prompt.replace(/\$\{userData\?.username \|\| 'User'\}/g, userData?.username || 'User');

            if (Object.keys(memory).length > 0) {
                let memoryContext = "\n\n--- User Memory ---\n";
                for (const key in memory) { memoryContext += `- ${key}: ${memory[key]}\n`; }
                systemPromptText += memoryContext;
            }

            const systemInstruction = { role: "system", parts: [{ text: systemPromptText }] }; // Ollama often uses 'system' role

            const historyLimit = settings.messageHistoryLimit || 50;
            const recentMessages = currentConversation.messages.slice(-historyLimit);

             const history = recentMessages.map(msg => {
                 let parts = [];
                 if(msg.text) parts.push({ text: msg.text });
                 // Include image data if present (assuming model supports it)
                 if (msg.image) {
                     try {
                         const base64Data = msg.image.split(',')[1];
                         // Heuristic to guess mimeType, might need improvement
                         const mimeType = msg.image.substring(msg.image.indexOf(':') + 1, msg.image.indexOf(';'));
                         if (base64Data && mimeType.startsWith('image/')) {
                             parts.push({ inlineData: { mimeType: mimeType, data: base64Data } });
                         }
                     } catch (e) { console.warn("Could not process image data for Ollama history:", e); }
                 }
                 return {
                     role: msg.sender === 'user' ? 'user' : 'model', // Use 'model' for Gemini compatibility layer
                     parts: parts.filter(p => p.text || p.inlineData)
                 };
             }).filter(msg => msg.parts.length > 0);

            return { history, systemInstruction }; // Return structure compatible with how it's used
        }


         async function processMemoryTags(responseText, baseMessageId) {
            const memoryRegex = /<Memory:"([^"]*?):([^"]*?)"\/?\>/g; // Non-greedy match
            let match;
            let cleanedText = responseText;
            let memoryUpdates = [];

            while ((match = memoryRegex.exec(responseText)) !== null) {
                const key = match[1]?.trim();
                const value = match[2]?.trim();
                if (key && value) {
                    memory[key] = value;
                    memoryUpdates.push({ key, value });
                    cleanedText = cleanedText.replace(match[0], '');
                    console.log(`Memory updated: ${key} = ${value}`);
                }
            }

            if (memoryUpdates.length > 0) {
                saveMemory();
                updateMemoryListUI();
                const updateMsgText = `Memory Updated: ${memoryUpdates.map(upd => `**${upd.key}** set`).join(', ')}`;
                addMessageToChat({
                    id: baseMessageId - 0.5,
                    text: updateMsgText,
                    sender: 'ai',
                    timestamp: Date.now(),
                    messageType: 'memoryUpdate'
                });
                 sendToTelegramBot(`Memory updated in conv ${currentConversation?.id}: ${JSON.stringify(memoryUpdates)}`);
            }
            return cleanedText.trim();
        }

        async function generateAndDisplayImage(prompt, messageId) {
            showIndicator('image');
            try {
                 if (plan !== 'premium') {
                    showPremiumAdModal("imageGeneration");
                    throw new Error("Image generation requires Premium plan.");
                 }
                 // Using Pollinations.ai proxy - Replace if using a different service
                 // IMPORTANT: Ensure the proxy/service aligns with safety and usage policies.
                 const encodedPrompt = encodeURIComponent(prompt);
                 const imageUrl = `https://image.pollinations.ai/prompt/${encodedPrompt}`; // Basic proxy

                 // Add message with placeholder/link first
                 const imageData = {
                    id: messageId,
                    text: `Generating image for: "${prompt}"...`,
                    sender: 'ai',
                    image: null, // No image src initially
                    timestamp: Date.now(),
                    messageType: 'imageGen'
                 };
                 addMessageToChat(imageData); // Add the text part first
                 currentConversation.messages.push({...imageData}); // Add to history immediately
                 saveConversations();
                 conversationMessageCount++;

                 // Attempt to fetch the image to confirm it exists and update the message
                 try {
                     const imageResponse = await fetch(imageUrl);
                     if (!imageResponse.ok) throw new Error(`Image generation failed (status: ${imageResponse.status})`);
                     // Update existing message element with the actual image
                     const msgElement = el.chatMessages.querySelector(`.message[data-message-id='${messageId}']`);
                     if(msgElement) {
                         msgElement.innerHTML = `<p>Image generated for: "${prompt}"</p>`; // Update text
                         const img = document.createElement('img');
                         img.src = imageUrl; // Use the final URL
                         img.className = 'message-image rounded-lg mt-2';
                         img.alt = `Generated Image: ${prompt}`;
                         img.onload = () => scrollToBottom(); // Scroll after image loads
                         msgElement.appendChild(img);
                         // Update message data in array as well
                         const msgIndex = currentConversation.messages.findIndex(m => m.id === messageId);
                         if (msgIndex !== -1) {
                             currentConversation.messages[msgIndex].image = imageUrl; // Store the final URL
                             currentConversation.messages[msgIndex].text = `Image generated for: "${prompt}"`; // Update text in array
                             saveConversations();
                         }
                     }
                 } catch (fetchError) {
                     console.error("Error fetching generated image:", fetchError);
                     // Update message to show error
                     const msgElement = el.chatMessages.querySelector(`.message[data-message-id='${messageId}']`);
                     if(msgElement) {
                          msgElement.innerHTML = `<p>Failed to load image for: "${prompt}" (Error: ${fetchError.message})</p>`;
                     }
                      // Update message data in array
                      const msgIndex = currentConversation.messages.findIndex(m => m.id === messageId);
                      if (msgIndex !== -1) {
                          currentConversation.messages[msgIndex].text = `Failed to load image for: "${prompt}" (Error: ${fetchError.message})`;
                           saveConversations();
                      }
                     throw fetchError; // Re-throw to be caught by outer catch
                 }

                 sendToTelegramBot(`AI generated image in conv ${currentConversation.id}`, 'info', `Prompt: ${prompt}`);

            } catch (error) {
                console.error("Error during image generation process:", error);
                const errorText = `Sorry, couldn't generate image: ${error.message}`;
                // Only add a *new* error message if the placeholder wasn't updated
                if (!currentConversation.messages.find(m => m.id === messageId)?.image) {
                   addAiTextMessage(errorText, messageId + 0.1, true); // Add separate error message
                }
                 showToast(`Image Generation Error: ${error.message}`, 'error');
                 sendToTelegramBot(`ERROR (Image Gen): ${error.message} in conv ${currentConversation.id}`, 'error');
            } finally {
                removeIndicator();
            }
        }

        async function executeAndDisplayJs(jsCode, messageId, captureOutput) {
             showIndicator('js');
             let resultMessageData = null;
             try {
                 const result = await evaluateJavascript(jsCode); // Use safe evaluation helper

                 if (captureOutput) {
                     resultMessageData = {
                        id: messageId,
                         // Format result nicely in a code block
                        text: `JavaScript Execution Result:\n\`\`\`javascript\n${result}\n\`\`\``,
                        sender: 'ai',
                        timestamp: Date.now(),
                        messageType: 'processJsResult'
                     };
                     addMessageToChat(resultMessageData);
                     currentConversation.messages.push(resultMessageData);
                     conversationMessageCount++;
                     sendToTelegramBot(`JS executed (output captured) in conv ${currentConversation.id}`, 'info', `Code: ${jsCode}\nResult: ${result}`);
                 } else {
                     // If no output needed, maybe show a small success message?
                     showToast('JavaScript executed.', 'info');
                     sendToTelegramBot(`JS executed (no output) in conv ${currentConversation.id}`, 'info', `Code: ${jsCode}`);
                     // Don't add a message bubble for no-output execution
                     // Decrement message count if we counted it prematurely? No, execution itself is an "action" from AI.
                 }
                 saveConversations();

             } catch (error) {
                 console.error("Error processing JavaScript:", error);
                 const errorText = `Error executing JavaScript: ${error.message}`;
                 addAiTextMessage(errorText, messageId, true); // Add error message
                 showToast(`JS Execution Error: ${error.message}`, 'error');
                 sendToTelegramBot(`ERROR (JS Exec): ${error.message} in conv ${currentConversation.id}`, 'error', `Code: ${jsCode}`);
             } finally {
                 removeIndicator();
             }
        }

        function addWebsitePreviewMessage(websiteCode, messageId) {
            const websiteData = {
                id: messageId,
                text: websiteCode, // Store the raw code
                sender: 'ai',
                timestamp: Date.now(),
                messageType: 'websiteCode'
            };
             addMessageToChat(websiteData); // Let addMessageToChat handle rendering
             currentConversation.messages.push(websiteData);
             saveConversations();
             conversationMessageCount++;
             sendToTelegramBot(`AI generated website code in conv ${currentConversation.id}`);
        }


         // Helper to add standard AI text messages
        function addAiTextMessage(text, messageId, isError = false) {
            // Avoid adding empty messages
            if (!text || text.trim().length === 0) {
                 console.warn("Attempted to add empty AI message, skipping.");
                 return;
            }
            const messageData = {
                id: messageId,
                text: text,
                sender: 'ai',
                timestamp: Date.now(),
                messageType: isError ? 'error' : 'text'
            };
            addMessageToChat(messageData);
            currentConversation.messages.push(messageData);
            saveConversations();
            conversationMessageCount++;
            if (!isError) {
                 sendAiResponseLog(messageData);
            }
        }


        // --- UI & Display ---

        function addMessageToChat(messageData) {
            const { id, text, sender, image, timestamp, file, messageType = 'text' } = messageData;

             // Ensure empty placeholder is hidden when first message added
             if (el.chatMessages.children.length <= Object.keys(el).filter(k => k.endsWith('Animation')).length + 1) { // +1 for placeholder
                 el.emptyChatPlaceholder.style.display = 'none';
             }


            const messageWrapper = document.createElement('div');
            messageWrapper.className = `message-wrapper ${sender === 'user' ? 'user-message-wrapper' : 'ai-message-wrapper'}`;
            // Context menu listeners are added dynamically or via delegation in setupEventListeners

            const messageElement = document.createElement('div');
             // Base classes + sender + type-specific class
             messageElement.className = `message ${sender === 'user' ? 'user-message' : 'ai-message'} ${messageType}-message animate__animated animate__fadeInUp`;
            messageElement.dataset.messageId = id;

            // --- Content Rendering based on messageType ---
            switch (messageType) {
                case 'memoryUpdate':
                    messageElement.className = 'memory-update-message animate__animated animate__fadeInUp'; // Override class
                    // Use marked.parseInline for potential markdown in the update message text
                    messageElement.innerHTML = `<i class="fas fa-brain mr-2"></i> ${marked.parseInline(text)}`;
                    break;

                case 'imageGen':
                     // Display text (prompt/status)
                     messageElement.innerHTML = `<p>${marked.parseInline(text)}</p>`;
                     // If image URL is available (after successful fetch), add the img tag
                     if (image) {
                        const img = document.createElement('img');
                        img.src = image;
                        img.className = 'message-image rounded-lg mt-2';
                        img.alt = 'Generated Image';
                        img.onerror = () => { img.alt = 'Error loading image'; img.src = ''; };
                        img.onload = () => scrollToBottom(); // Scroll when image loads
                        messageElement.appendChild(img);
                    }
                    break;

                 case 'websiteCode':
                     // Ensure DOMPurify is used carefully with srcdoc
                     // Sanitize HTML slightly differently for srcdoc - allow styles, basic structure
                      const sanitizedHtml = DOMPurify.sanitize(text, {
                         USE_PROFILES: { html: true }, // Allow safe HTML tags
                         // ADD_TAGS: ['style'], // Allow style tags if desired (use with caution)
                         // ADD_ATTR: ['style']   // Allow style attributes if desired (use with caution)
                      });

                     messageElement.innerHTML = `
                        <div class="website-preview-header-chat">
                            <span class="title"><i class="fas fa-code mr-2"></i> index.html Preview</span>
                            <div class="actions">
                                <button onclick="window.downloadWebsiteCode(${id})" title="Download HTML"><i class="fas fa-download"></i></button>
                                <button onclick="window.openWebsiteInNewTab(${id})" title="Open in New Tab"><i class="fas fa-external-link-alt"></i></button>
                            </div>
                        </div>
                        <div class="website-preview-area-chat">
                            <iframe class="website-preview-iframe" sandbox="allow-scripts allow-same-origin" loading="lazy" srcdoc="${sanitizedHtml.replace(/"/g, '&quot;')}"></iframe>
                        </div>
                     `;
                     messageElement.classList.add('website-code-message'); // Specific styling class
                     break;

                case 'processJsResult':
                    // Text contains the formatted result including backticks for code block
                    // Marked will handle rendering the code block inside.
                    messageElement.innerHTML = marked.parse(text || ""); // Render markdown
                    break;

                default: // Includes 'text', user messages with images/files, errors
                     let contentHtml = '';
                     if (text) {
                         // Use marked.parse for AI text, parseInline for user text? Or just parse for both.
                         // Relying on earlier input sanitization for user messages.
                          contentHtml = marked.parse(text || "");
                     }

                     if (image && sender === 'user') { // User image upload
                         const img = `<img src="${image}" class="message-image rounded-lg mt-2" alt="User Uploaded Image" loading="lazy">`;
                         contentHtml += img;
                     } else if (file && sender === 'user') { // User file upload
                         const fileLink = `
                            <a href="#" class="message-file" title="Type: ${file.type}, Size: ${(file.size / 1024).toFixed(1)} KB">
                                <i class="fas fa-file-alt mr-2"></i> ${DOMPurify.sanitize(file.name)}
                            </a>`;
                         contentHtml += fileLink;
                         // Note: Making the file downloadable requires reading it as blob/DataURL which can be memory intensive.
                         // Consider server-side handling for large file downloads if needed.
                     }
                     messageElement.innerHTML = contentHtml;
                     break;
             }


            // Add actions (hover buttons - desktop only)
             if(window.innerWidth >= 768) { // Only add hover actions on desktop
                const actionsDiv = createMessageActions(id, sender);
                if (actionsDiv) messageElement.appendChild(actionsDiv);
             }

            messageWrapper.appendChild(messageElement);

            // Timestamp
            if (timestamp) {
                const timeElement = document.createElement('div');
                timeElement.className = 'message-time';
                timeElement.textContent = formatTimestamp(timestamp);
                messageWrapper.appendChild(timeElement);
            }

            // Insert before indicators and scroll
            el.chatMessages.insertBefore(messageWrapper, el.printingAnimation);
            scrollToBottom();

            // Highlight code blocks within the new message
            messageElement.querySelectorAll('pre code').forEach(highlightCodeBlock);

            // Update regenerate button state
            el.regenerateHeaderButton.style.display = canRegenerate() ? 'block' : 'none';
        }

        function createMessageActions(messageId, sender) {
             // Don't add actions to memory update messages or JS results for now
              const messageType = currentConversation?.messages.find(m => m.id === messageId)?.messageType;
              if (messageType === 'memoryUpdate' || messageType === 'processJsResult') {
                  return null;
              }


            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'message-actions';
            let buttons = '';

            if (sender === 'user') {
                buttons = `
                    <button class="message-action-button edit-button" title="Edit message" data-action="edit" data-message-id="${messageId}"><i class="fas fa-edit"></i></button>
                    <button class="message-action-button delete-button" title="Delete message" data-action="delete" data-message-id="${messageId}"><i class="fas fa-trash"></i></button>
                `;
            } else { // AI message
                 buttons = `
                    <button class="message-action-button copy-button" title="Copy message" data-action="copy" data-message-id="${messageId}"><i class="fas fa-copy"></i></button>
                    <button class="message-action-button regenerate-button" title="Regenerate response" data-action="regenerate" data-message-id="${messageId}"><i class="fas fa-sync"></i></button>
                    <button class="message-action-button delete-button" title="Delete message" data-action="delete" data-message-id="${messageId}"><i class="fas fa-trash"></i></button>
                `;
            }
            actionsDiv.innerHTML = buttons;

            // Add event listeners directly here for hover buttons
            actionsDiv.querySelectorAll('button').forEach(button => {
                button.addEventListener('click', handleMessageActionClick);
            });

            return actionsDiv;
        }

        function handleMessageActionClick(event) {
             event.stopPropagation();
             const button = event.currentTarget;
             const action = button.dataset.action;
             const messageId = parseInt(button.dataset.messageId);
             const messageElement = el.chatMessages.querySelector(`.message[data-message-id='${messageId}']`);

             console.log(`Action Click: ${action}, Message ID: ${messageId}`);
             hideContextMenu(); // Hide context menu if open

             switch (action) {
                 case 'edit': editPrompt(messageId); break;
                 case 'delete': deleteOutput(messageId); break;
                 case 'regenerate': regenerateOutput(messageId); break;
                 case 'copy': copyMessageToClipboard(messageId, messageElement); break;
             }
        }

        function highlightCodeBlock(block) {
             hljs.highlightElement(block);
             // Add copy button if not already present in parent pre
             const preElement = block.closest('pre');
             if (preElement && !preElement.querySelector('.copy-code-button')) {
                 const copyButton = document.createElement('button');
                 copyButton.className = 'copy-code-button';
                 copyButton.innerHTML = '<i class="fas fa-copy mr-1"></i> Copy';
                 copyButton.onclick = () => copyCodeToClipboard(block.textContent);
                 preElement.style.position = 'relative'; // Ensure parent is positioned
                 preElement.appendChild(copyButton);
             }
        }


        // --- Context Menu Logic ---
        function handleContextMenu(event, messageId, sender) {
             event.preventDefault();
             contextMenuTargetMessage = messageId;
             const isUserMessage = sender === 'user';
             const isAiMessage = sender === 'ai'; // Includes various AI message types

              // Find the message type
             const message = currentConversation?.messages.find(m => m.id === messageId);
             const messageType = message?.messageType;

             // Enable/disable buttons based on sender and type
             el.editContextButton.style.display = isUserMessage ? 'flex' : 'none';
             // Allow copying AI text, code, JS results, but maybe not images directly?
             el.copyContextButton.style.display = (isAiMessage && messageType !== 'imageGen' && messageType !== 'memoryUpdate') ? 'flex' : 'none';
             // Allow regenerating AI responses (excluding memory/JS results for now)
             el.regenerateContextButton.style.display = (isAiMessage && messageType !== 'memoryUpdate' && messageType !== 'processJsResult') ? 'flex' : 'none';
             // Allow deleting both user and AI messages (excluding memory updates?)
             el.deleteContextButton.style.display = (messageType !== 'memoryUpdate') ? 'flex' : 'none';

             // Check if any button is visible
              const anyButtonVisible = Array.from(messageContextMenu.children).some(btn => btn.style.display !== 'none');
              if (anyButtonVisible) {
                positionContextMenu(event);
                showContextMenu();
              } else {
                 contextMenuTargetMessage = null; // Reset if no actions available
              }
        }
        function handleTouchStart(event, messageId, sender) {
            clearTimeout(touchTimer); // Clear any previous timer
            touchStartTime = Date.now();
            touchTimer = setTimeout(() => {
                // Prevent context menu if scrolling
                 if (Math.abs(event.touches[0].clientY - touchStartY) < 10) { // Simple check for vertical scroll
                    handleContextMenu(event.touches[0], messageId, sender); // Use touch event position
                 }
            }, 600); // Long press duration (slightly longer for touch)
            touchStartY = event.touches[0].clientY; // Store initial Y position
        }
        function handleTouchEnd() { clearTimeout(touchTimer); }
        function positionContextMenu(event) {
             const menu = messageContextMenu;
             const clickX = event.clientX;
             const clickY = event.clientY;
             const screenW = window.innerWidth;
             const screenH = window.innerHeight;
             const menuW = menu.offsetWidth;
             const menuH = menu.offsetHeight;

             menu.style.left = `${Math.max(5, (clickX + menuW > screenW) ? screenW - menuW - 5 : clickX)}px`; // Ensure not off-screen left
             menu.style.top = `${Math.max(5, (clickY + menuH > screenH) ? screenH - menuH - 5 : clickY)}px`; // Ensure not off-screen top
        }
        function showContextMenu() {
            messageContextMenu.style.display = 'block';
            messageContextMenu.classList.remove('animate__fadeOut'); // Ensure fade-in animation runs
            messageContextMenu.classList.add('animate__fadeIn');
        }
        function hideContextMenu() {
            if (messageContextMenu.style.display === 'block') {
                messageContextMenu.classList.remove('animate__fadeIn');
                 messageContextMenu.classList.add('animate__fadeOut'); // Add fade-out
                 setTimeout(() => {
                     messageContextMenu.style.display = 'none';
                     messageContextMenu.classList.remove('animate__fadeOut'); // Clean up class
                     contextMenuTargetMessage = null;
                 }, 200); // Match animation duration
            }
        }
        function handleGlobalClick(event) {
             // Hide context menu if clicked outside
             if (messageContextMenu.style.display === 'block' && !messageContextMenu.contains(event.target) && !event.target.closest('.message-wrapper')) { // Don't close if clicking another message
                 hideContextMenu();
             }
             // Hide mobile sidebar if clicked outside
              if (window.innerWidth < 768 && el.sidebar.classList.contains('active') && !el.sidebar.contains(event.target) && !el.mobileSidebarToggleChat.contains(event.target)) {
                 toggleSidebar();
             }
              // Close conversation dropdowns if clicked outside
               document.querySelectorAll('.conversation-actions-dropdown-content.show').forEach(dropdown => {
                   if (!dropdown.parentElement.contains(event.target)) {
                       dropdown.classList.remove('show');
                   }
               });
        }
        function handleContextMenuAction(event) {
             const action = event.currentTarget.id.replace('-context-button', '');
             const messageId = contextMenuTargetMessage;
             const messageElement = el.chatMessages.querySelector(`.message[data-message-id='${messageId}']`);
             hideContextMenu(); // Hide menu *after* action selected

             if (!messageId || !messageElement) return;

             console.log(`Context Action: ${action}, Message ID: ${messageId}`);

             switch (action) {
                 case 'edit': editPrompt(messageId); break;
                 case 'copy': copyMessageToClipboard(messageId, messageElement); break;
                 case 'regenerate': regenerateOutput(messageId); break;
                 case 'delete': deleteOutput(messageId); break;
             }
        }

        // --- Message Actions ---
        function editPrompt(messageId) {
             const message = currentConversation.messages.find(msg => msg.id === messageId);
             if (!message || message.sender !== 'user') return;

             editingMessageId = messageId;
             el.editMessageTextarea.value = message.text;
             showModal(el.editMessageModal);
        }
        function cancelEditMessage() { hideModal(el.editMessageModal); editingMessageId = null; }
        async function saveEditMessage() {
            const editedMessageText = DOMPurify.sanitize(el.editMessageTextarea.value.trim(), { USE_PROFILES: { html: false } });
            if (!editedMessageText || editingMessageId === null) {
                showToast("Message cannot be empty.", 'info');
                return;
            }

            const messageIndex = currentConversation.messages.findIndex(msg => msg.id === editingMessageId);
            if (messageIndex === -1 || currentConversation.messages[messageIndex].sender !== 'user') {
                 cancelEditMessage(); return;
            }

            // Update the user message data
            currentConversation.messages[messageIndex].text = editedMessageText;
            currentConversation.messages[messageIndex].timestamp = Date.now();

            // --- Remove subsequent messages (AI responses) ---
             const messagesToRemoveIds = [];
             const wrappersToRemove = [];
             // Iterate from the message *after* the edited one
             for (let i = messageIndex + 1; i < currentConversation.messages.length; i++) {
                 const msg = currentConversation.messages[i];
                 messagesToRemoveIds.push(msg.id);
                 const wrapper = el.chatMessages.querySelector(`.message[data-message-id='${msg.id}']`)?.closest('.message-wrapper');
                 if (wrapper) wrappersToRemove.push(wrapper);
                 // Decrement message count for removed AI messages
                 if (msg.sender !== 'user') {
                     conversationMessageCount--;
                 }
             }
             // Remove from DOM
             wrappersToRemove.forEach(wrapper => wrapper.remove());
             // Remove from array
             currentConversation.messages.splice(messageIndex + 1);


             // --- Update the DOM for the edited user message ---
             const userMessageElement = el.chatMessages.querySelector(`.message[data-message-id='${editingMessageId}']`);
             if (userMessageElement) {
                 const actionsDivHtml = userMessageElement.querySelector('.message-actions')?.outerHTML || '';
                 userMessageElement.innerHTML = marked.parse(editedMessageText) + actionsDivHtml;
                 userMessageElement.querySelectorAll('pre code').forEach(highlightCodeBlock);
                 const timeElement = userMessageElement.closest('.message-wrapper')?.querySelector('.message-time');
                 if (timeElement) timeElement.textContent = formatTimestamp(Date.now());
             }

             saveConversations();
             hideModal(el.editMessageModal);
             showToast('Message updated. Re-running...', 'info');
             sendToTelegramBot(`User message ${editingMessageId} edited in conv ${currentConversation.id}`);

             // --- Re-run the prompt ---
             el.regenerateHeaderButton.style.display = 'none';
             NProgress.start();
             if (!settings.ollamaEnabled) {
                 await getGeminiResponse(currentConversation.messages[messageIndex]);
             } else {
                 await getOllamaResponse();
             }
             NProgress.done();
             editingMessageId = null;
             el.regenerateHeaderButton.style.display = canRegenerate() ? 'block' : 'none';
        }

        function deleteOutput(messageId) {
             if (!confirm("Delete this message? This cannot be undone.")) return;

             const messageIndex = currentConversation.messages.findIndex(msg => msg.id === messageId);
             if (messageIndex !== -1) {
                 const messageWrapper = el.chatMessages.querySelector(`.message[data-message-id='${messageId}']`)?.closest('.message-wrapper');

                 if (currentConversation.messages[messageIndex].sender !== 'user') {
                     conversationMessageCount--;
                 }
                 currentConversation.messages.splice(messageIndex, 1);
                 if (messageWrapper) messageWrapper.remove();
                 saveConversations();
                 showToast('Message deleted.', 'success');
                 sendToTelegramBot(`Message ${messageId} deleted from conv ${currentConversation.id}`);
                 el.regenerateHeaderButton.style.display = canRegenerate() ? 'block' : 'none';

                  // If deleting the last message makes the chat empty, show placeholder
                  if (currentConversation.messages.length === 0) {
                       el.emptyChatPlaceholder.style.display = 'flex';
                       el.chatInputArea.classList.add('conversation-empty');
                       updateStarterMessagesArea();
                  }
             }
        }

        async function regenerateOutput(aiMessageId) {
             const aiMessageIndex = currentConversation.messages.findIndex(msg => msg.id === aiMessageId);
             if (aiMessageIndex === -1 || currentConversation.messages[aiMessageIndex].sender === 'user') {
                  showToast("Cannot regenerate this message.", 'error');
                  return;
             }


             // Find the preceding user message that triggered this AI response
             let userMessageIndex = -1;
             for (let i = aiMessageIndex - 1; i >= 0; i--) {
                 if (currentConversation.messages[i].sender === 'user') {
                     userMessageIndex = i;
                     break;
                 }
             }

             if (userMessageIndex === -1) {
                 showToast("Cannot regenerate: No preceding user message found.", 'error');
                 console.error("Regenerate failed: Could not find user message before AI message ID", aiMessageId);
                 return;
             }

             const userMessageData = currentConversation.messages[userMessageIndex];

             showToast('Regenerating response...', 'info');

             // --- Remove the AI message being regenerated AND any subsequent messages ---
             const wrappersToRemove = [];
             // Iterate from the AI message index to the end
             for (let i = aiMessageIndex; i < currentConversation.messages.length; i++) {
                  const msg = currentConversation.messages[i];
                  const wrapper = el.chatMessages.querySelector(`.message[data-message-id='${msg.id}']`)?.closest('.message-wrapper');
                  if (wrapper) wrappersToRemove.push(wrapper);
                  // Decrement message count for removed AI messages
                  if (msg.sender !== 'user') {
                      conversationMessageCount--;
                  }
             }
              // Remove from DOM
              wrappersToRemove.forEach(wrapper => wrapper.remove());
             // Remove from array (starting from the AI message index)
             currentConversation.messages.splice(aiMessageIndex);


             saveConversations();
             sendToTelegramBot(`Regenerating response for message ${aiMessageId} in conv ${currentConversation.id}`);

             // Trigger AI again
             el.regenerateHeaderButton.style.display = 'none';
             NProgress.start();
             if (!settings.ollamaEnabled) {
                 await getGeminiResponse(userMessageData);
             } else {
                 await getOllamaResponse();
             }
             NProgress.done();
             el.regenerateHeaderButton.style.display = canRegenerate() ? 'block' : 'none';
        }

        function regenerateLastResponse() {
            if (!currentConversation || currentConversation.messages.length === 0) return;
            // Find the last AI message in the conversation
             let lastAiMessageId = null;
             for (let i = currentConversation.messages.length - 1; i >= 0; i--) {
                 if (currentConversation.messages[i].sender !== 'user' && currentConversation.messages[i].messageType !== 'memoryUpdate') {
                     lastAiMessageId = currentConversation.messages[i].id;
                     break;
                 }
             }

            if (lastAiMessageId) {
                regenerateOutput(lastAiMessageId);
            } else {
                showToast("No AI response available to regenerate.", "info");
            }
        }

        function canRegenerate() {
             if (!currentConversation || currentConversation.messages.length === 0) return false;
             // Check if there's at least one AI message that isn't a memory update
              return currentConversation.messages.some(msg => msg.sender !== 'user' && msg.messageType !== 'memoryUpdate');
        }


        function copyMessageToClipboard(messageId, messageElement) {
            const message = currentConversation.messages.find(msg => msg.id === messageId);
            if (!message) return;

            let textToCopy = message.text;

            // If it's a website code message, copy the raw HTML
             if (message.messageType === 'websiteCode') {
                textToCopy = message.text; // Already have the raw code
            }
             // If it's a JS result, maybe just copy the result part?
             else if (message.messageType === 'processJsResult') {
                 const codeMatch = message.text.match(/```javascript\n([\s\S]*?)\n```/);
                 textToCopy = codeMatch ? codeMatch[1] : message.text; // Extract code or fallback to full text
             }
              else if (messageElement) {
                 // Fallback: try to get innerText for standard messages
                 const contentElement = messageElement.querySelector('.message-content') || messageElement;
                 textToCopy = contentElement.innerText || contentElement.textContent;
             }


             navigator.clipboard.writeText(textToCopy).then(() => {
                 showToast('Message copied!', 'success');
             }).catch(err => {
                 console.error('Failed to copy message:', err);
                 showToast('Failed to copy message.', 'error');
             });
        }

        function copyCodeToClipboard(code) {
            navigator.clipboard.writeText(code).then(() => {
                showToast('Code copied!', 'success');
            }).catch(err => {
                console.error('Failed to copy code:', err);
                showToast('Failed to copy code.', 'error');
            });
        }

        // Website preview helpers (global scope)
         window.downloadWebsiteCode = function(messageId) {
            const message = currentConversation?.messages.find(msg => msg.id == messageId && msg.messageType === 'websiteCode');
            if (message && message.text) {
                try {
                    const blob = new Blob([message.text], { type: 'text/html' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'index.html';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showToast('Website code downloaded!', 'success');
                } catch (e) {
                    showToast('Error downloading code.', 'error');
                     console.error("Download error:", e);
                }
            } else {
                showToast('Could not find website code to download.', 'error');
            }
        }
         window.openWebsiteInNewTab = function(messageId) {
             const message = currentConversation?.messages.find(msg => msg.id == messageId && msg.messageType === 'websiteCode');
             if (message && message.text) {
                 try {
                    const blob = new Blob([message.text], {type : 'text/html'});
                    const url = URL.createObjectURL(blob);
                    window.open(url, '_blank');
                    // No need to revoke immediately, browser handles it when tab closes
                    showToast('Website opened in new tab!', 'success');
                 } catch (e) {
                     showToast('Error opening website preview.', 'error');
                     console.error("Preview error:", e);
                 }
             } else {
                 showToast('Could not find website code to preview.', 'error');
             }
        }


        // --- Sidebar & Conversation Management ---

        function createNewConversation() {
            // Check free plan limit (only count non-archived)
            if (plan === 'free' && conversations.filter(c => !c.archived).length >= MAX_CONVERSATIONS) {
                 showPremiumAdModal("conversationLimit");
                 console.log("Free conversation limit reached.");
                return;
            }

            const newConversation = {
                id: Date.now(),
                name: 'New Chat',
                messages: [],
                assistant: 'default',
                createdAt: Date.now(),
                archived: false,
                pinned: false,
            };
            conversations.unshift(newConversation);
            // Increment created count *only if* on free plan (for tracking total creations vs limit)
            // This counter isn't strictly needed if we just check length, but kept for potential future use
            if (plan === 'free') usageCounters.conversationsCreated++;
            saveConversations();
            saveUsageCounters();
            updateConversationList();
            switchConversation(newConversation);
            sendToTelegramBot(`New conversation created: ${newConversation.id}`);
        }

        function updateConversationList() {
            const searchTerm = el.searchConversationsInput.value.toLowerCase();

            const pinnedConvs = conversations.filter(c => c.pinned && !c.archived);
            const normalConvs = conversations.filter(c => !c.pinned && !c.archived);
            const archivedConvs = conversations.filter(c => c.archived);

             pinnedConvs.sort((a, b) => (b.updatedAt || b.createdAt) - (a.updatedAt || a.createdAt)); // Sort by last updated/created
             normalConvs.sort((a, b) => (b.updatedAt || b.createdAt) - (a.updatedAt || a.createdAt));
             archivedConvs.sort((a, b) => (b.updatedAt || b.createdAt) - (a.updatedAt || a.createdAt));

            const filterConv = (conv) =>
                conv.name.toLowerCase().includes(searchTerm) ||
                conv.messages.some(msg => msg.text && msg.text.toLowerCase().includes(searchTerm));

            const displayList = (listElement, convs, isArchived = false) => {
                listElement.innerHTML = '';
                const filtered = convs.filter(filterConv);
                filtered.forEach(conv => {
                    const li = createConversationListItem(conv, isArchived);
                    listElement.appendChild(li);
                });
                listElement.parentElement.style.display = filtered.length > 0 ? 'block' : 'none';
            };

            displayList(el.pinnedList, pinnedConvs);
            displayList(el.conversationList, normalConvs);
            displayList(el.archivedList, archivedConvs, true);

            // Update sortable lists if needed (currently not implemented for conv lists)
            // initializeSortableLists();
        }


        function createConversationListItem(conv, isArchived) {
             const li = document.createElement('li');
             li.className = `conversation-item ${currentConversation?.id === conv.id ? 'active' : ''} ${conv.pinned ? 'pinned-conversation' : ''}`;
             li.dataset.convId = conv.id;

             const nameToShow = DOMPurify.sanitize(conv.name);

             const pinIconClass = conv.pinned ? 'fas fa-thumbtack rotate-45 text-yellow-500' : 'fas fa-thumbtack';
             const archiveIconClass = isArchived ? 'fas fa-folder-open' : 'fas fa-archive';
             const pinTitle = conv.pinned ? 'Unpin' : 'Pin';
             const archiveTitle = isArchived ? 'Unarchive' : 'Archive';

             li.innerHTML = `
                <span class="conversation-title flex-grow text-gray-700 dark:text-gray-300">${nameToShow}</span>
                 <!-- Desktop Actions (Hidden on Mobile) -->
                <div class="conversation-actions flex-shrink-0 md:flex hidden">
                    ${!isArchived ? `<button class="pin-button" title="${pinTitle}"><i class="${pinIconClass}"></i></button>` : ''}
                    <button class="rename-button" title="Rename"><i class="fas fa-edit"></i></button>
                    <button class="archive-button" title="${archiveTitle}"><i class="${archiveIconClass}"></i></button>
                    <button class="delete-button" title="Delete"><i class="fas fa-trash"></i></button>
                </div>
                 <!-- Mobile Dropdown Trigger (Visible on Mobile) -->
                 <div class="conversation-actions-mobile-dropdown md:hidden flex-shrink-0">
                     <button class="conversation-actions-mobile-button" aria-label="More actions"><i class="fas fa-ellipsis-v"></i></button>
                     <div class="conversation-actions-dropdown-content">
                        ${!isArchived ? `<button class="pin-button"><i class="${pinIconClass}"></i> ${pinTitle}</button>` : ''}
                         <button class="rename-button"><i class="fas fa-edit"></i> Rename</button>
                         <button class="archive-button"><i class="${archiveIconClass}"></i> ${archiveTitle}</button>
                         <button class="delete-button"><i class="fas fa-trash"></i> Delete</button>
                     </div>
                 </div>
            `;

             // Event listeners
             li.addEventListener('click', (e) => {
                 if (!e.target.closest('button')) switchConversation(conv);
             });

            li.querySelectorAll('.pin-button').forEach(btn => btn.addEventListener('click', (e) => { e.stopPropagation(); pinConversation(conv.id); hideAllConvDropdowns(); }));
            li.querySelectorAll('.rename-button').forEach(btn => btn.addEventListener('click', (e) => { e.stopPropagation(); renameConversation(conv.id); hideAllConvDropdowns(); }));
            li.querySelectorAll('.archive-button').forEach(btn => btn.addEventListener('click', (e) => { e.stopPropagation(); archiveConversation(conv.id); hideAllConvDropdowns(); }));
            li.querySelectorAll('.delete-button').forEach(btn => btn.addEventListener('click', (e) => { e.stopPropagation(); deleteConversation(conv.id); hideAllConvDropdowns(); }));
            li.querySelector('.conversation-actions-mobile-button')?.addEventListener('click', (e) => { e.stopPropagation(); toggleConversationActionsDropdown(e); });


             return li;
        }

         function toggleConversationActionsDropdown(event) {
            const button = event.currentTarget;
            const dropdown = button.nextElementSibling; // Assumes dropdown is the next sibling
            if (!dropdown) return;

            const isCurrentlyShown = dropdown.classList.contains('show');

            // Close all other open dropdowns first
            hideAllConvDropdowns();

            // Toggle the current one if it wasn't the one already open
            if (!isCurrentlyShown) {
                dropdown.classList.add('show');
            }
         }

         function hideAllConvDropdowns() {
              document.querySelectorAll('.conversation-actions-dropdown-content.show').forEach(d => {
                  d.classList.remove('show');
              });
         }


        function pinConversation(id) {
            const conversation = conversations.find(conv => conv.id === id);
            if (conversation && !conversation.archived) {
                conversation.pinned = !conversation.pinned;
                conversation.updatedAt = Date.now();
                saveConversations();
                updateConversationList();
                showToast(`Chat ${conversation.pinned ? 'pinned' : 'unpinned'}.`, 'info');
                sendToTelegramBot(`Conversation ${id} ${conversation.pinned ? 'pinned' : 'unpinned'}.`);
            }
        }
        function renameConversation(id) {
            const conversation = conversations.find(conv => conv.id === id);
            if (!conversation) return;

            const newName = prompt("Enter new chat name:", conversation.name);
            const sanitizedName = DOMPurify.sanitize(newName || '', { USE_PROFILES: { html: false } }).trim(); // Sanitize input

            if (sanitizedName && sanitizedName !== conversation.name) {
                const oldName = conversation.name;
                conversation.name = sanitizedName;
                 conversation.updatedAt = Date.now();
                saveConversations();
                updateConversationList();
                if (currentConversation?.id === id) {
                    el.currentConversationTitle.textContent = conversation.name;
                }
                 showToast('Chat renamed.', 'success');
                sendToTelegramBot(`Conv ${id} renamed from "${oldName}" to "${conversation.name}".`);
            } else if (newName !== null) { // Handle case where user entered empty or only whitespace
                showToast("Invalid chat name.", "error");
            }
        }
        function archiveConversation(id) {
             const conversation = conversations.find(conv => conv.id === id);
             if (!conversation) return;

             const wasArchived = conversation.archived;
             conversation.archived = !conversation.archived;
             conversation.pinned = false;
             conversation.updatedAt = Date.now();
             saveConversations();
             updateConversationList();

             showToast(`Chat ${conversation.archived ? 'archived' : 'unarchived'}.`, 'info');
             sendToTelegramBot(`Conversation ${id} ${conversation.archived ? 'archived' : 'unarchived'}.`);

             // If the currently active conversation was just archived, switch
             if (currentConversation?.id === id && conversation.archived) {
                 switchToFirstAvailableConversation();
             }
        }
        function deleteConversation(id) {
             const conversation = conversations.find(conv => conv.id === id);
             if (!conversation) return;

             if (confirm(`Delete chat "${conversation.name}"? This cannot be undone.`)) {
                 const conversationName = conversation.name;
                 conversations = conversations.filter(conv => conv.id !== id);
                 saveConversations();
                 updateConversationList();

                 showToast(`Chat "${conversationName}" deleted.`, 'success');
                 sendToTelegramBot(`Conversation "${conversationName}" (${id}) deleted.`);

                 if (currentConversation?.id === id) {
                     switchToFirstAvailableConversation();
                 }
             }
        }

        // Helper to switch to the first available (non-archived) conversation or clear the view
         function switchToFirstAvailableConversation() {
            const nextConversation = conversations.find(c => !c.archived && !c.pinned) || conversations.find(c => !c.archived);
            if (nextConversation) {
                 switchConversation(nextConversation);
            } else {
                 // No available chats left
                 currentConversation = null;
                 clearChatMessages();
                 el.currentConversationTitle.textContent = "Select or Start a Chat";
                 el.chatInputArea.classList.add('conversation-empty');
                 updateStarterMessagesArea();
                 el.emptyChatPlaceholder.style.display = 'flex';
                 el.regenerateHeaderButton.style.display = 'none';
                 localStorage.removeItem('lastActiveConversationId');
            }
         }

        function switchConversation(conversation) {
             // Handle potential null conversation input gracefully
             if (!conversation) {
                 console.log("Attempted to switch to null conversation. Finding fallback.");
                 switchToFirstAvailableConversation(); // Try to find a fallback
                 return; // Exit if still no conversation found
             }
            if (currentConversation?.id === conversation.id) return;

            currentConversation = conversation;
            localStorage.setItem('lastActiveConversationId', conversation.id);

            clearChatMessages();
            el.emptyChatPlaceholder.style.display = 'none'; // Hide placeholder initially

            if (conversation.messages.length === 0) {
                 el.chatInputArea.classList.add('conversation-empty');
                 updateStarterMessagesArea();
                 el.emptyChatPlaceholder.style.display = 'flex'; // Show empty state placeholder
            } else {
                conversation.messages.forEach(addMessageToChat);
                el.chatInputArea.classList.remove('conversation-empty');
                 el.starterMessagesArea.style.display = 'none'; // Hide starters
            }

            el.currentConversationTitle.textContent = DOMPurify.sanitize(conversation.name || 'Chat');
            updateConversationList();
            conversationMessageCount = conversation.messages.filter(m => m.sender !== 'user' && m.messageType !== 'memoryUpdate').length; // Count only AI turns excluding memory updates

             // Close mobile sidebar after selection
             if (window.innerWidth < 768 && el.sidebar.classList.contains('active')) {
                toggleSidebar();
             }
             el.regenerateHeaderButton.style.display = canRegenerate() ? 'block' : 'none';
             scrollToBottom(); // Ensure scroll to bottom on switch

             console.log(`Switched to conversation: ${conversation.id} (${conversation.name})`);
        }

        function clearChatMessages() {
             const indicators = [
                 el.printingAnimation, el.imageGeneratingAnimation, el.ollamaGeneratingAnimation,
                 el.websiteGeneratingAnimation, el.processJsAnimation
             ];
             el.chatMessages.innerHTML = ''; // Clear all content
             el.chatMessages.appendChild(el.emptyChatPlaceholder); // Re-add placeholder (initially hidden)
             indicators.forEach(indicator => el.chatMessages.appendChild(indicator));
        }

        function toggleSidebar() {
             // No change in logic needed here, just ensure classes are correct
             sidebarCollapsed = !sidebarCollapsed;
             const isMobile = window.innerWidth < 768;

             if (isMobile) {
                 el.sidebar.classList.toggle('active', sidebarCollapsed);
                 el.toggleSidebarMobileButton.innerHTML = sidebarCollapsed ? '<i class="fas fa-times"></i>' : '<i class="fas fa-bars"></i>';
             } else {
                 el.sidebar.classList.toggle('sidebar-closed', sidebarCollapsed);
                 el.toggleSidebarDesktopButton.innerHTML = sidebarCollapsed ? '<i class="fas fa-chevron-right"></i>' : '<i class="fas fa-chevron-left"></i>';
             }
             console.log("Sidebar toggled, collapsed:", sidebarCollapsed);
        }


        // --- Settings Logic ---
        function openSettings() {
             document.getElementById('message-history-limit').value = settings.messageHistoryLimit;
             populateAiModelSelect();
             document.getElementById('ai-model').value = settings.aiModel;
             document.getElementById('theme').value = settings.theme;
             el.aiAssistantModeSelect.value = settings.aiAssistantMode;
             el.ollamaEnabledCheckbox.checked = settings.ollamaEnabled;
             el.ollamaApiUrlInput.value = settings.ollamaApiUrl;
             el.ollamaModelSelect.value = settings.ollamaModel;
             toggleOllamaSettingsVisibility();
             updateMemoryListUI();
             showModal(el.settingsModal);
        }
        function closeSettings() { hideModal(el.settingsModal); }
        function saveSettingsChanges() {
             const selectedModel = document.getElementById('ai-model').value;
             if (plan === 'free' && !PREMIUM_MODELS.slice(0, 1).includes(selectedModel)) {
                 showToast(`Free plan limited to ${getModelName(FREE_MODEL_FLASH)}.`, 'info');
                 document.getElementById('ai-model').value = settings.aiModel;
                 return;
             }

             settings.messageHistoryLimit = Math.max(10, Math.min(100, parseInt(document.getElementById('message-history-limit').value) || 50)); // Clamp value
             settings.aiModel = selectedModel;
             settings.theme = document.getElementById('theme').value;
             settings.aiAssistantMode = el.aiAssistantModeSelect.value;
             settings.ollamaEnabled = el.ollamaEnabledCheckbox.checked;
             settings.ollamaApiUrl = el.ollamaApiUrlInput.value.trim() || 'http://localhost:11434'; // Default if empty
             settings.ollamaModel = el.ollamaModelSelect.value;

             saveSettings();
             applySettings();
             closeSettings();
             showToast('Settings saved!', 'success');
             sendToTelegramBot('Settings updated.');
        }
        function applySettings() {
             applyTheme();
             initializeModel(); // Re-initialize model
             updateNewAssistantModeUI();
             updatePlanLimits();
        }
        function applyTheme() {
            const theme = settings.theme;
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            document.body.classList.remove('dark', 'light'); // Clear existing theme classes

            if (theme === 'dark' || (theme === 'system' && prefersDark)) {
                document.body.classList.add('dark');
            } else {
                 document.body.classList.add('light'); // Add light class explicitly or rely on default
            }
             console.log("Theme applied:", document.body.classList.contains('dark') ? 'Dark' : 'Light');
        }
        function toggleOllamaSettingsVisibility() {
            el.ollamaSettingsDiv.classList.toggle('hidden', !el.ollamaEnabledCheckbox.checked);
        }
        function populateAiModelSelect() {
             const select = document.getElementById('ai-model');
             const currentSelection = select.value; // Preserve selection if possible
             select.innerHTML = '';

             const availableModels = plan === 'premium' ? PREMIUM_MODELS : [FREE_MODEL_FLASH];

             availableModels.forEach(modelId => {
                 const option = document.createElement('option');
                 option.value = modelId;
                 option.textContent = getModelName(modelId);
                 select.appendChild(option);
             });
              // Try to restore selection
              if (availableModels.includes(currentSelection)) {
                 select.value = currentSelection;
              } else {
                 select.value = availableModels[0]; // Default to first available if previous selection is no longer valid
              }
        }
         function getModelName(modelId) {
            switch(modelId) {
                case 'gemini-2.0-flash-lite': return 'PyroAI Flash';
                case 'gemini-2.0-flash-thinking-exp-01-21': return 'PyroAI Pro (Premium)';
                case 'gemini-2.5-pro-exp-03-25': return 'PyroAI Max (Premium)'; // Corrected model ID
                default: return modelId;
            }
        }


        // --- Assistant Management Logic ---
        function openAssistantModal() { updateAssistantList(); showModal(el.assistantModal); }
        function closeAssistantModal() { hideModal(el.assistantModal); }
        function updateAssistantList() {
             el.assistantList.innerHTML = '';
             assistants.forEach(assistant => {
                const card = document.createElement('div');
                card.className = `assistant-card bg-white dark:bg-gray-700 p-4 rounded-lg shadow hover:shadow-md transition-shadow duration-200 cursor-pointer border ${currentConversation?.assistant === assistant.id ? 'border-primary-500 ring-2 ring-primary-300' : 'border-gray-200 dark:border-gray-600'} flex flex-col justify-between`;
                const description = assistant.description ? `<p class="text-sm text-gray-600 dark:text-gray-400 mb-3">${DOMPurify.sanitize(assistant.description)}</p>` : '';
                const isDefault = assistant.id === 'default';
                const isActive = currentConversation?.assistant === assistant.id;

                card.innerHTML = `
                    <div>
                        <h3 class="text-md font-semibold mb-1 text-gray-800 dark:text-gray-200 flex items-center">
                             ${DOMPurify.sanitize(assistant.name)}
                             ${isActive ? '<i class="fas fa-check-circle text-green-500 ml-2 text-xs" title="Active in current chat"></i>' : ''}
                        </h3>
                        ${description}
                    </div>
                    <div class="flex justify-end items-center mt-2 text-gray-500 dark:text-gray-400 gap-2">
                         ${isDefault ? '<span class="text-xs italic mr-auto px-2 py-0.5 bg-gray-100 dark:bg-gray-600 rounded">Default</span>' : ''}
                         <button class="edit-assistant-button hover:text-primary-500 transition-colors p-1 rounded hover:bg-gray-100 dark:hover:bg-gray-600" data-assistant-id="${assistant.id}" title="Edit Assistant">
                             <i class="fas fa-edit"></i>
                         </button>
                         ${!isDefault ? `<button class="delete-assistant-button hover:text-red-500 transition-colors p-1 rounded hover:bg-gray-100 dark:hover:bg-gray-600" data-assistant-id="${assistant.id}" title="Delete Assistant">
                             <i class="fas fa-trash"></i>
                         </button>` : ''}
                     </div>
                 `;
                 card.onclick = (e) => { if (!e.target.closest('button')) selectAssistant(assistant.id); };
                 card.querySelector('.edit-assistant-button')?.addEventListener('click', (e) => { e.stopPropagation(); openNewAssistantModal(assistant.id); });
                 card.querySelector('.delete-assistant-button')?.addEventListener('click', (e) => { e.stopPropagation(); deleteAssistant(assistant.id); });
                 el.assistantList.appendChild(card);
             });
        }
        function openNewAssistantModal(assistantIdToEdit = null) {
            const isEditing = assistantIdToEdit !== null;
            el.newAssistantModalTitle.innerHTML = isEditing ? '<i class="fas fa-edit mr-2"></i> Edit Assistant' : '<i class="fas fa-plus-circle mr-2"></i> Create New Assistant';
            el.editingAssistantIdInput.value = ''; // Clear hidden ID input initially

            if (isEditing) {
                const assistant = assistants.find(a => a.id === assistantIdToEdit);
                if (!assistant) return;
                el.editingAssistantIdInput.value = assistant.id; // Set the ID for editing
                el.assistantNameInput.value = assistant.name;
                el.assistantDescriptionInput.value = assistant.description || '';
                el.assistantPromptTextarea.value = assistant.prompt;
            } else {
                el.assistantNameInput.value = '';
                el.assistantDescriptionInput.value = '';
                // Pre-fill prompt with a basic structure example?
                 el.assistantPromptTextarea.value = `You are a helpful AI assistant.
Capabilities:
- Conversation
- Use <imageGen:"prompt"> for images.
- Use <processJS:"code", "output:Bool"> for JS.
- Use <Memory:"key:value"> to remember facts.
User: ${userData?.username || 'User'}.
Current Date & Time: ${new Date().toLocaleString()}`;
            }

            updateNewAssistantModeUI();
            showModal(el.newAssistantModal);
        }
        function closeNewAssistantModal() {
            hideModal(el.newAssistantModal);
             el.generateAssistantPromptButton.style.display = 'none';
             el.saveNewAssistantButton.style.display = 'inline-block';
             el.promptModeAutoArea.classList.add('hidden');
             el.promptModeManualArea.style.display = 'block';
        }
        function updateNewAssistantModeUI() {
             const mode = settings.aiAssistantMode;
             const isEditing = !!el.editingAssistantIdInput.value; // Cannot auto-generate when editing

             if (mode === 'auto' && !isEditing) { // Only allow auto-gen for NEW assistants
                 el.promptModeManualArea.style.display = 'none';
                 el.generateAssistantPromptButton.style.display = 'inline-block';
                 el.saveNewAssistantButton.style.display = 'none';
             } else { // Manual mode or editing existing
                 el.promptModeManualArea.style.display = 'block';
                 el.promptModeAutoArea.classList.add('hidden');
                 el.generateAssistantPromptButton.style.display = 'none';
                 el.saveNewAssistantButton.style.display = 'inline-block';
             }
        }
        async function generateAiAssistantPrompt() {
            const name = el.assistantNameInput.value.trim();
            const description = el.assistantDescriptionInput.value.trim();

            if (!name) { showToast("Enter an assistant name to generate prompt.", 'info'); return; }
            if (!genAI && !ollamaEnabled) { showToast("AI model not available for generation.", 'error'); return; }


            el.promptModeManualArea.style.display = 'none';
            el.promptModeAutoArea.classList.remove('hidden');
            el.generateAssistantPromptButton.disabled = true; // Disable button during generation

            try {
                 let promptGenModel;
                 let generatedPrompt = '';

                 // Use Gemini Flash if available, otherwise try Ollama if enabled
                 if (genAI) {
                     promptGenModel = genAI.getGenerativeModel({ model: FREE_MODEL_FLASH });
                     const promptRequest = `Generate a concise and effective system prompt for an AI assistant.
                         Name: "${name}"
                         Description: "${description}"
                         Capabilities might include: Conversation, <imageGen:"prompt">, <processJS:"code","output:Bool">, <Memory:"key:value">.
                         Focus on defining its core role, personality (optional), and instructions. Incorporate the Name and Description naturally. Output ONLY the system prompt text, nothing else. Start with 'You are...'. Include user placeholder '${userData?.username || 'User'}' and current date/time placeholder.`;
                     const result = await promptGenModel.generateContent(promptRequest);
                     generatedPrompt = result.response.text().trim();
                 } else if (ollamaEnabled) {
                     // Basic Ollama prompt generation (might be less reliable than Gemini)
                     const ollamaPromptRequest = `Generate a concise system prompt for an AI chatbot named "${name}" with description "${description}". Include common capabilities like conversation, image generation, JS execution, and memory. Output only the prompt text. Start with 'You are...'.`;
                      const ollamaResponse = await fetch(`${settings.ollamaApiUrl}/api/generate`, {
                         method: 'POST', headers: { 'Content-Type': 'application/json' },
                         body: JSON.stringify({ model: settings.ollamaModel, prompt: ollamaPromptRequest, stream: false })
                      });
                      if (!ollamaResponse.ok) throw new Error('Ollama generation failed');
                      const ollamaData = await ollamaResponse.json();
                      generatedPrompt = ollamaData?.response?.trim() || 'You are a helpful assistant.'; // Fallback
                 } else {
                     throw new Error("No suitable AI model found for generation.");
                 }


                // Inject dynamic parts if generator didn't include them
                 if (!generatedPrompt.includes(userData?.username || 'User')) {
                    generatedPrompt += `\nUser: ${userData?.username || 'User'}.`;
                 }
                 if (!generatedPrompt.includes('Current Date & Time:')) {
                    generatedPrompt += `\nCurrent Date & Time: ${new Date().toLocaleString()}`;
                 }


                el.assistantPromptTextarea.value = generatedPrompt;
                showToast("AI prompt generated!", 'success');

            } catch (error) {
                console.error("Error generating assistant prompt:", error);
                showToast("Error generating prompt. Please try manually.", 'error');
                sendToTelegramBot(`Error generating assistant prompt: ${error.message}`, 'error');
            } finally {
                 el.promptModeAutoArea.classList.add('hidden');
                 el.promptModeManualArea.style.display = 'block';
                 el.saveNewAssistantButton.style.display = 'inline-block'; // Show save button
                 el.generateAssistantPromptButton.disabled = false; // Re-enable button
                 el.generateAssistantPromptButton.style.display = 'none'; // Hide generate button after attempt
            }
        }
        function saveNewAssistant() {
             const id = el.editingAssistantIdInput.value || Date.now().toString();
             const name = DOMPurify.sanitize(el.assistantNameInput.value.trim(), { USE_PROFILES: { html: false } });
             const description = DOMPurify.sanitize(el.assistantDescriptionInput.value.trim(), { USE_PROFILES: { html: false } });
             const prompt = el.assistantPromptTextarea.value.trim(); // Assume prompt is safe or handled by AI service
             const isEditing = !!el.editingAssistantIdInput.value;

             if (!name || !prompt) { showToast("Assistant name and prompt are required.", 'error'); return; }

             const newAssistantData = { id, name, description, prompt };

             if (isEditing) {
                 const index = assistants.findIndex(a => a.id === id);
                 if (index !== -1) {
                     assistants[index] = newAssistantData;
                     showToast('Assistant updated!', 'success');
                     sendToTelegramBot(`Assistant edited: ${name} (${id})`);
                 }
             } else {
                 assistants.push(newAssistantData);
                 showToast('Assistant created!', 'success');
                 sendToTelegramBot(`New assistant created: ${name} (${id})`);
             }

             saveAssistants();
             updateAssistantList();
             closeNewAssistantModal();
        }
        function selectAssistant(assistantId) {
            if (currentConversation && currentConversation.assistant !== assistantId) {
                const selectedAssistant = assistants.find(a => a.id === assistantId);
                if (selectedAssistant) {
                     currentConversation.assistant = assistantId;
                     saveConversations();
                     closeAssistantModal();
                     addMessageToChat({
                         id: Date.now(),
                         text: `Switched to assistant: **${DOMPurify.sanitize(selectedAssistant.name)}**`,
                         sender: 'ai',
                         timestamp: Date.now(),
                         messageType: 'memoryUpdate' // Use memory style for info message
                     });
                     showToast(`Switched to assistant: ${selectedAssistant.name}`, 'info');
                     sendToTelegramBot(`Switched conv ${currentConversation.id} to assistant: "${selectedAssistant.name}" (${assistantId})`);
                }
            } else if (currentConversation && currentConversation.assistant === assistantId) {
                closeAssistantModal(); // Just close if already selected
            } else {
                 // Handle case where no conversation is active? Maybe select for next new chat?
                 closeAssistantModal();
            }
            updateAssistantList(); // Update highlighting in modal
        }
         function deleteAssistant(id) {
             if (id === 'default') { showToast("Cannot delete the default assistant.", 'error'); return; }
             const assistant = assistants.find(a => a.id === id);
             if (!assistant) return;

             if (confirm(`Delete assistant "${assistant.name}"? This cannot be undone.`)) {
                 const assistantName = assistant.name;
                 assistants = assistants.filter(a => a.id !== id);
                 saveAssistants();
                 updateAssistantList();

                 let updatedConversations = false;
                 conversations.forEach(conv => {
                     if (conv.assistant === id) { conv.assistant = 'default'; updatedConversations = true; }
                 });
                 if (updatedConversations) saveConversations();

                 if (currentConversation && currentConversation.assistant === id) {
                     currentConversation.assistant = 'default';
                     addMessageToChat({
                         id: Date.now(), text: `Assistant "${assistantName}" was deleted. Switched to default assistant.`, sender: 'ai', timestamp: Date.now(), messageType: 'memoryUpdate'
                     });
                 }

                 showToast(`Assistant "${assistantName}" deleted.`, 'success');
                 sendToTelegramBot(`Assistant "${assistantName}" (${id}) deleted.`);
             }
        }
         function exportAssistants() {
             try {
                 // Filter out potentially sensitive info if needed before export, though prompts are the main content here.
                const jsonContent = JSON.stringify(assistants, null, 2);
                const blob = new Blob([jsonContent], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'pyroai_assistants_export.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showToast('Assistants exported!', 'success');
             } catch (error) {
                 console.error("Error exporting assistants:", error);
                 showToast("Failed to export assistants.", 'error');
             }
        }
        function triggerAssistantImport() {
             const fileInput = document.createElement('input');
             fileInput.type = 'file';
             fileInput.accept = '.json';
             fileInput.style.display = 'none';
             fileInput.onchange = (event) => {
                 const file = event.target.files?.[0];
                 if (file) { importAssistantFromFile(file); }
                 document.body.removeChild(fileInput);
             };
             document.body.appendChild(fileInput);
             fileInput.click();
        }
        function importAssistantFromFile(file) {
             const reader = new FileReader();
             reader.onload = function(event) {
                 try {
                     const importedData = JSON.parse(event.target.result);
                     if (Array.isArray(importedData)) {
                         const validAssistants = importedData.filter(a => a && typeof a.id === 'string' && a.name && a.prompt);
                         const newAssistants = validAssistants.filter(imp => !assistants.some(ex => ex.id === imp.id));

                         if (newAssistants.length > 0) {
                            assistants = assistants.concat(newAssistants);
                            saveAssistants();
                            updateAssistantList();
                            showToast(`${newAssistants.length} new assistant(s) imported!`, 'success');
                            sendToTelegramBot(`${newAssistants.length} assistants imported.`);
                         } else if (validAssistants.length > 0) {
                             showToast('No new assistants found (existing IDs skipped).', 'info');
                         } else {
                              showToast('No valid assistants found in the file.', 'error');
                         }

                     } else { showToast('Invalid file format. Expected a JSON array.', 'error'); }
                 } catch (e) {
                     console.error("Error importing assistants:", e);
                     showToast('Error reading or parsing file.', 'error');
                     sendToTelegramBot(`Error importing assistants: ${e.message}`, 'error');
                 }
             };
             reader.onerror = () => { showToast('Error reading file.', 'error'); };
             reader.readAsText(file);
        }


        // --- Memory Management ---
        function updateMemoryListUI() {
            el.memoryListElement.innerHTML = '';
            const memoryKeys = Object.keys(memory);

            if (memoryKeys.length === 0) {
                el.memoryListElement.innerHTML = '<p class="text-gray-500 dark:text-gray-400 text-center p-2">No memories saved yet.</p>';
                return;
            }

            memoryKeys.forEach(key => {
                const memoryItem = document.createElement('div');
                 // Use DOMPurify for key and value display
                const safeKey = DOMPurify.sanitize(key);
                const safeValue = DOMPurify.sanitize(memory[key]);
                memoryItem.className = 'memory-item flex justify-between items-center text-sm mb-1 py-1 px-2 rounded bg-gray-100 dark:bg-gray-600 hover:bg-gray-200 dark:hover:bg-gray-500';
                memoryItem.innerHTML = `
                    <div class="flex-grow mr-2 overflow-hidden">
                        <span class="font-semibold">${safeKey}:</span>
                        <span class="truncate" title="${safeValue}">${safeValue}</span>
                    </div>
                    <button class="memory-delete-btn text-red-500 hover:text-red-700 ml-2 p-1 flex-shrink-0" data-memory-key="${key}" title="Delete memory">
                        <i class="fas fa-times-circle"></i>
                    </button>
                `;
                el.memoryListElement.appendChild(memoryItem);
            });
        }
        function handleMemoryDelete(event) {
            const deleteButton = event.target.closest('.memory-delete-btn');
            if (deleteButton) {
                const memoryKey = deleteButton.dataset.memoryKey;
                if (memoryKey && confirm(`Delete memory "${memoryKey}"?`)) {
                    delete memory[memoryKey];
                    saveMemory();
                    updateMemoryListUI();
                    showToast('Memory deleted.', 'success');
                    sendToTelegramBot(`Memory deleted: ${memoryKey}`);
                }
            }
        }
        function clearAllMemory() {
            if (confirm("Clear ALL saved memories? This cannot be undone.")) {
                memory = {};
                saveMemory();
                updateMemoryListUI();
                showToast('All memories cleared.', 'success');
                sendToTelegramBot('All memories cleared by user.');
            }
        }


        // --- Premium & Limits Logic ---
        function activatePremiumPlan() {
             const enteredKey = el.premiumKeyInputModal.value.trim();
             if (!enteredKey) return;

             if (premiumKeys.includes(enteredKey)) {
                 setPlan('premium');
                 closePremiumKeyModal();
                 showToast("Premium plan activated! Enjoy the enhanced features.", 'success');
                 sendToTelegramBot('Premium plan ACTIVATED.');
             } else {
                 el.premiumKeyStatus.classList.remove('hidden');
                 el.premiumKeyInputModal.classList.add('border-red-500', 'animate__animated', 'animate__headShake'); // Feedback
                 setTimeout(() => el.premiumKeyInputModal.classList.remove('border-red-500', 'animate__animated', 'animate__headShake'), 1000);
                 showToast('Invalid premium key.', 'error');
                 sendToTelegramBot('Invalid Premium Key entered.', 'warning');
             }
        }
        function setPlan(newPlan) {
            if (plan === newPlan) return;
            plan = newPlan;
            savePlan();
            updatePlanUI();
            updateSidebarUI();
            initializeModel(); // Re-init model
            console.log(`Plan changed to: ${plan}`);
        }
        function updatePlanUI() {
             updatePlanLimits();
             populateAiModelSelect(); // Update available models in settings dropdown
             el.premiumButton.style.display = plan === 'premium' ? 'none' : 'flex';
        }
         function updatePlanLimits() {
             MESSAGE_LIMIT = plan === 'premium' ? 40 : 15;
             MAX_CONVERSATIONS = plan === 'premium' ? Infinity : 3; // Free limit check done on creation
             DAILY_MESSAGE_LIMIT = plan === 'premium' ? 100 : 10;
             DAILY_IMAGE_LIMIT = plan === 'premium' ? 20 : 3; // Files count towards this limit too
             MAX_MESSAGE_CHARS = plan === 'premium' ? 10000 : 1000;
             console.log("Limits updated for plan:", plan, { MESSAGE_LIMIT, MAX_CONVERSATIONS, DAILY_MESSAGE_LIMIT, DAILY_IMAGE_LIMIT, MAX_MESSAGE_CHARS });
        }
        function updateSidebarUI() {
            el.sidebarUsername.textContent = userData?.username || 'User';
            el.premiumUserBadge.innerHTML = plan === 'premium' ? '<span class="premium-badge animate__animated animate__pulse animate__infinite animate__slower">Premium</span>' : '';
        }
        function showPremiumAdModal(reason = "limit") {
             sendToTelegramBot(`Premium Ad shown. Reason: ${reason}. Usage: Msgs=${usageCounters.dailyMessages}/${DAILY_MESSAGE_LIMIT}, Imgs=${usageCounters.dailyImages}/${DAILY_IMAGE_LIMIT}, Convs=${conversations.filter(c => !c.archived).length}/${MAX_CONVERSATIONS === Infinity ? '∞' : MAX_CONVERSATIONS}`);
            showModal(el.premiumAdModal);
        }
        function closePremiumAdModal() { hideModal(el.premiumAdModal); }
        function showPremiumKeyModal() { showModal(el.premiumKeyModal); el.premiumKeyStatus.classList.add('hidden'); el.premiumKeyInputModal.value = '';}
        function closePremiumKeyModal() { hideModal(el.premiumKeyModal); }

        function checkMessageLimit() { return conversationMessageCount < MESSAGE_LIMIT; }
        function checkDailyMessageLimit() { return usageCounters.dailyMessages < DAILY_MESSAGE_LIMIT; }
        function checkDailyImageLimit() { return usageCounters.dailyImages < DAILY_IMAGE_LIMIT; }
        function checkDailyLimitsReset() {
            const today = new Date().toDateString();
            if (usageCounters.lastResetDate !== today) {
                 console.log("Resetting daily limits for", today);
                 usageCounters.dailyMessages = 0;
                 usageCounters.dailyImages = 0;
                 usageCounters.lastResetDate = today;
                 saveUsageCounters();
                 sendToTelegramBot('Daily usage limits reset.');
            }
        }


        // --- Initial Setup & Welcome ---
        function showInitialSetupModal() { showModal(el.initialSetupModal); }
        function closeInitialSetupModal() { hideModal(el.initialSetupModal); }
        function showWelcomeModal() { showModal(el.welcomeModal); }
        function closeWelcomeModal() { hideModal(el.welcomeModal); }
        function showAgeBlockModal() { showModal(el.ageBlockModal); }
        function closeAgeBlockModal() { hideModal(el.ageBlockModal); /* Maybe redirect or disable further interaction */ }
        function acceptTerms() {
            localStorage.setItem('termsAccepted', 'true');
            closeWelcomeModal();
            if (!userData) {
                 showInitialSetupModal();
            } else {
                 showToast('Terms accepted. Welcome back!', 'success');
                  // Ensure UI is correct if user already exists
                  if (currentConversation && currentConversation.messages.length === 0) {
                      el.chatInputArea.classList.add('conversation-empty');
                      updateStarterMessagesArea();
                      el.emptyChatPlaceholder.style.display = 'flex';
                  }
            }
            sendToTelegramBot('Terms accepted.');
        }
        function completeInitialSetup() {
             let isValid = true;
             const username = el.setupUsernameInput.value.trim();
             const dob = el.setupDobInput.value;
             const email = el.setupEmailInput.value.trim();
             const pin = el.setupPinInput.value;

             [el.usernameError, el.dobError, el.emailError, el.pinError].forEach(e => e.classList.add('hidden'));

             if (username.length < 3 || username.length > 20) { el.usernameError.classList.remove('hidden'); isValid = false; }
             if (!dob) { el.dobError.classList.remove('hidden'); isValid = false; }
             if (email && !isValidEmail(email)) { el.emailError.classList.remove('hidden'); isValid = false; }
             if (!/^\d{4}$/.test(pin)) { el.pinError.classList.remove('hidden'); isValid = false; }

             // Age Check
             let age = 0;
             if (dob) {
                 try {
                     const birthDate = new Date(dob);
                     // More robust age calculation
                     const today = new Date();
                     age = today.getFullYear() - birthDate.getFullYear();
                     const m = today.getMonth() - birthDate.getMonth();
                     if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
                         age--;
                     }
                     if (age < 18) {
                         el.dobError.textContent = "You must be 18 or older to use PyroAI.";
                         el.dobError.classList.remove('hidden');
                         isValid = false;
                     }
                 } catch (e) {
                     el.dobError.textContent = "Invalid date format.";
                     el.dobError.classList.remove('hidden');
                     isValid = false;
                 }
             }

             if (!isValid) return;

             // Save data (Sanitize username before saving?)
             const sanitizedUsername = DOMPurify.sanitize(username, { USE_PROFILES: { html: false } });
             // IMPORTANT: Storing PIN directly in localStorage is insecure.
             // For a real application, hash the PIN server-side during login/auth.
             // Here, we store it directly for client-side-only functionality.
             userData = { username: sanitizedUsername, email, pin };
             saveUserData();
             closeInitialSetupModal();
             showToast(`Setup complete! Welcome, ${sanitizedUsername}!`, 'success');
             sendToTelegramBot(`New User Setup: ${sanitizedUsername}, Email: ${email || 'N/A'}, Age: ${age}`);
             updateSidebarUI();
             loadAssistants(); // Reload assistants to inject correct username into prompts

             // Show welcome modal AFTER setup is complete
              if (localStorage.getItem('termsAccepted') !== 'true') {
                  showWelcomeModal();
              } else {
                  // Start the app if terms were somehow accepted before setup
                   if (currentConversation && currentConversation.messages.length === 0) {
                       el.chatInputArea.classList.add('conversation-empty');
                       updateStarterMessagesArea();
                       el.emptyChatPlaceholder.style.display = 'flex';
                   }
              }
        }

        // --- Suggestions ---
        function openSuggestionsModal() { showModal(el.suggestionsModal); el.suggestionTextarea.value = '';}
        function closeSuggestionsModal() { hideModal(el.suggestionsModal); }
        async function sendSuggestions() {
             const suggestionText = el.suggestionTextarea.value.trim();
             if (!suggestionText) { showToast("Please enter your feedback.", 'info'); return; }

             // Add context automatically
             const context = `User: ${userData?.username || 'Guest'}, Plan: ${plan}, Current Conv: ${currentConversation?.id || 'None'}`;
             const fullFeedback = `Feedback:\n${suggestionText}\n\nContext: [${context}]`;

             closeSuggestionsModal();
             showToast('Sending feedback...', 'info');
             try {
                await sendToTelegramBot(`Feedback Received: ${fullFeedback}`);
                showToast('Feedback sent. Thank you!', 'success');
                el.suggestionTextarea.value = '';
             } catch (error) {
                  showToast('Failed to send feedback. Please try again.', 'error');
             }
        }


        // --- File & Image Handling ---
         async function readFileAsDataURL(file) { /* ... no change ... */ }
         async function fileToGenerativePart(file) { /* ... no change ... */ }
         function handleFileUpload(event) {
             const file = event.target.files?.[0];
             if (!file) { clearFileInput(); clearImagePreview(); return; }

             // Simple size check (e.g., 20MB limit for client-side processing)
             const maxSizeMB = 20;
             if (file.size > maxSizeMB * 1024 * 1024) {
                 showToast(`File too large (max ${maxSizeMB}MB).`, 'error');
                 clearFileInput();
                 return;
             }


             if (file.type.startsWith('image/')) {
                 if (!checkDailyImageLimit()) { showPremiumAdModal("dailyImageLimit"); clearFileInput(); return; }
                 selectedImageFile = file;
                 selectedFile = null;
                 displayImagePreview(file);
                 // Don't clear file input value here, allow browser state
             } else {
                 if (!checkDailyImageLimit()) { showPremiumAdModal("dailyImageLimit"); clearFileInput(); return; }
                 selectedFile = file;
                 selectedImageFile = null;
                 clearImagePreview();
                 showToast(`File ready: ${file.name}`, 'info');
                 // Optionally add a visual cue next to attach button?
             }
              // Manually clear the input value after processing to allow selecting the same file again
               event.target.value = null;
         }
         function displayImagePreview(file) { /* ... no change ... */ }
         function clearImagePreview() { /* ... no change ... */ }
         function clearFileInput() {
             selectedFile = null;
             el.fileUploadInput.value = ''; // Clear file input value
             // Remove file info indicator if implemented
         }


        // --- UI Helpers ---
        function showModal(modalElement) { /* ... no change ... */ }
        function hideModal(modalElement) { /* ... no change ... */ }
        function showIndicator(type = 'gemini') {
             // Hide all first
             removeIndicator();
             // Show the correct one
             const indicatorMap = {
                 gemini: el.printingAnimation,
                 image: el.imageGeneratingAnimation,
                 ollama: el.ollamaGeneratingAnimation,
                 website: el.websiteGeneratingAnimation,
                 js: el.processJsAnimation
             };
             if (indicatorMap[type]) {
                 indicatorMap[type].style.display = 'flex';
             }
             scrollToBottom();
        }
        function removeIndicator() {
             el.printingAnimation.style.display = 'none';
             el.imageGeneratingAnimation.style.display = 'none';
             el.ollamaGeneratingAnimation.style.display = 'none';
             el.websiteGeneratingAnimation.style.display = 'none';
             el.processJsAnimation.style.display = 'none';
        }
        function scrollToBottom() {
             // Use requestAnimationFrame for smoother scrolling after DOM updates
             requestAnimationFrame(() => {
                 el.chatMessages.scrollTop = el.chatMessages.scrollHeight;
             });
        }
        function showToast(message, type = 'info', duration = 3200) {
             const toast = document.createElement('div');
             toast.className = `toast toast-${type} animate__animated animate__faster`; // Add base animation class

             const iconClass = { success: 'fa-check-circle', error: 'fa-exclamation-triangle', info: 'fa-info-circle' }[type] || 'fa-info-circle';
             toast.innerHTML = `<i class="fas ${iconClass} mr-2"></i> ${DOMPurify.sanitize(message)}`; // Sanitize toast message

             el.toastContainer.appendChild(toast);
             toast.classList.add('animate__slideInRight'); // Trigger entrance animation

             setTimeout(() => {
                 toast.classList.remove('animate__slideInRight');
                 toast.classList.add('animate__fadeOut'); // Trigger fade out
                 toast.addEventListener('animationend', () => toast.remove()); // Remove after fade out completes
             }, duration);
        }
        function formatTimestamp(timestamp) { /* ... no change ... */ }
        function updateStarterMessagesArea() {
             if (!currentConversation || currentConversation.messages.length > 0) {
                el.starterMessagesArea.style.display = 'none'; // Hide if chat has messages
                return;
             }
             el.starterMessagesArea.innerHTML = ''; // Clear existing
             starterMessages.forEach(msg => {
                const button = document.createElement('button');
                button.className = 'starter-message-button';
                button.textContent = msg;
                button.onclick = () => {
                    el.userInput.value = msg;
                    autoSizeTextarea();
                    if (!settings.ollamaEnabled) sendMessage('gemini'); else sendMessage('ollama');
                };
                el.starterMessagesArea.appendChild(button);
             });
             el.starterMessagesArea.style.display = 'grid'; // Show starter grid
        }
        function startCooldown() {
            messageCooldown = true;
            el.sendButton.disabled = true;
            el.ollamaSendButton.disabled = true;
            el.userInput.disabled = true;
            el.userInput.placeholder = "Please wait..."; // Indicate cooldown

            clearTimeout(messageCooldownTimeout);
            messageCooldownTimeout = setTimeout(() => {
                removeCooldown();
            }, 1500); // 1.5 second cooldown
        }
         function removeCooldown() {
             messageCooldown = false;
             el.sendButton.disabled = false;
             el.ollamaSendButton.disabled = !settings.ollamaApiUrl || !settings.ollamaEnabled;
             el.userInput.disabled = false;
             el.userInput.placeholder = "Type your message...";
             clearTimeout(messageCooldownTimeout);
         }


        // --- Utilities ---
        function debounce(func, wait) { /* ... no change ... */ }
        function isValidEmail(email) { /* ... no change ... */ }
        async function evaluateJavascript(jsCode) {
             console.log("Evaluating JS:", jsCode);
             // Using Async Function constructor for slightly safer, async-capable evaluation
             // WARNING: Still executes arbitrary code. Use with extreme caution.
             // Consider a more robust sandboxing mechanism if dealing with untrusted code sources.
             return new Promise(async (resolve, reject) => {
                 try {
                     const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;
                     const func = new AsyncFunction(jsCode);
                     const result = await func();
                     console.log("JS Result:", result);
                     resolve(result !== undefined ? String(result) : "undefined");
                 } catch (error) {
                     console.error("JavaScript evaluation error:", error);
                     reject(error);
                 }
             });
        }

        // --- Logging ---
        async function sendToTelegramBot(message, logType = 'info', details = null) {
            if (!botToken || !chatId || botToken === "YOUR_TELEGRAM_BOT_TOKEN") { return; } // Skip if not configured

            const logPrefix = `[PyAIv2|${logType.toUpperCase()}]`;
            const userInfo = userData ? `${userData.username}` : 'Guest';
            const ua = navigator.userAgent || "Unknown Agent";
            let os = "Unknown OS";
            if (ua.includes("Win")) os = "Win"; else if (ua.includes("Mac")) os = "Mac"; else if (ua.includes("Linux")) os = "Linux"; else if (ua.includes("Android")) os = "Android"; else if (ua.includes("like Mac")) os = "iOS";
            const browser = ua.includes("Firefox") ? "Fx" : ua.includes("Chrome") ? "Chr" : ua.includes("Safari") ? "Saf" : ua.includes("Edge") ? "Edge" : "Other";
            const timestamp = new Date().toLocaleTimeString(); // Shorter timestamp

            let fullMessage = `${logPrefix} ${message} [${userInfo}|${plan}|${browser}|${os}] (${timestamp})`;
             if (details) { fullMessage += `\n-- Details --\n${details}`; }

            const MAX_TG_LENGTH = 4000;
            if (fullMessage.length > MAX_TG_LENGTH) { fullMessage = fullMessage.substring(0, MAX_TG_LENGTH) + "... (truncated)"; }

            const apiUrl = `https://api.telegram.org/bot${botToken}/sendMessage`;
            try {
                // Use 'navigator.sendBeacon' for reliability on page unload, fallback to fetch
                 if (logType === 'unload' && navigator.sendBeacon) {
                     const blob = new Blob([JSON.stringify({ chat_id: chatId, text: fullMessage })], { type: 'application/json' });
                     navigator.sendBeacon(apiUrl, blob);
                 } else {
                    await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ chat_id: chatId, text: fullMessage }), keepalive: (logType === 'unload') }); // Use keepalive for unload fetch too
                 }
            } catch (error) { console.error('Error sending log to Telegram:', error); }
        }
        function sendUserMessageLog(messageData) { /* ... no change ... */ }
        function sendAiResponseLog(messageData) { /* ... no change ... */ }


        // --- Drag & Drop / Sortable ---
        function initializeSortable() {
             if (sortable) sortable.destroy();
             if (window.innerWidth >= 768) {
                sortable = new Sortable(el.chatMessages, {
                    animation: 150,
                    handle: '.message-wrapper',
                    // More robust filtering: only allow dragging user messages
                    filter: '.ai-message-wrapper, .typing-indicator, #printing-animation, #image-generating-animation, #process-js-animation, #ollama-generating-animation, #website-generating-animation, .memory-update-message, .empty-chat-placeholder',
                    preventOnFilter: true,
                    onUpdate: handleMessageSort,
                });
             } else { sortable = null; }
        }
        function handleMessageSort(evt) {
             // This function attempts to reorder ONLY the user messages in the
             // underlying 'currentConversation.messages' array based on the new DOM order.
             // AI messages are kept relative to their preceding user message where possible.
             // This is complex and might not be perfect in all edge cases.
             const itemEl = evt.item;
             const draggedMessageId = parseInt(itemEl.querySelector('.message')?.dataset.messageId);
             if (!draggedMessageId || !currentConversation) return;

             console.log("Attempting message sort...");

             // 1. Get the new order of ALL message IDs from the DOM
             const allMessageIdsInDom = Array.from(el.chatMessages.querySelectorAll('.message-wrapper .message[data-message-id]'))
                                            .map(el => parseInt(el.dataset.messageId));

             // 2. Create a lookup for the original messages by ID
             const originalMessagesMap = new Map(currentConversation.messages.map(msg => [msg.id, msg]));

             // 3. Reconstruct the messages array based on the new DOM order
             const newMessagesArray = [];
             allMessageIdsInDom.forEach(id => {
                 if (originalMessagesMap.has(id)) {
                     newMessagesArray.push(originalMessagesMap.get(id));
                     originalMessagesMap.delete(id); // Remove from map once placed
                 }
             });

              // Add any messages that were somehow missed (e.g., indicators, shouldn't happen for messages)
              originalMessagesMap.forEach(missedMsg => newMessagesArray.push(missedMsg));


              // 4. Filter out any potential null/undefined entries (safety check)
              const finalMessages = newMessagesArray.filter(Boolean);

             // 5. Update the conversation
             currentConversation.messages = finalMessages;
             saveConversations();
             console.log("Conversation messages reordered based on DOM.");
             showToast("Message order updated.", "info");

              // Re-run AI from the point of the drag? Not standard, usually just visual reorder.
              // If re-run is desired, need to find the user message preceding the first AI message
              // after the dragged message's new position, then call regenerate/resend. Complex.
        }
        // function initializeSortableLists() { /* ... Conversation list sorting (optional) ... */ }


        // --- Window Resize & Unload ---
        function handleWindowResize() {
             initializeSortable(); // Enable/disable message sorting
             if (window.innerWidth >= 768 && el.sidebar.classList.contains('active')) {
                 toggleSidebar(); // Close mobile sidebar if resizing to desktop
             }
        }
         // Add unload listener for logging
         window.addEventListener('beforeunload', () => {
            sendToTelegramBot('Site left or refreshed.', 'unload');
         });


        // --- Final Setup ---
        marked.setOptions({
            breaks: true, gfm: true, headerIds: false, mangle: false, // disable mangle
            highlight: function (code, lang) {
                const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                try {
                    return hljs.highlight(code, { language, ignoreIllegals: true }).value;
                } catch (e) { return hljs.highlightAuto(code).value; }
            }
        });
         // Add DOMPurify hook to handle target="_blank" on links rendered from Markdown
         DOMPurify.addHook('afterSanitizeAttributes', function (node) {
            if ('target' in node) { node.setAttribute('target', '_blank'); }
             // Prevent JavaScript links
             if ('href' in node && node.getAttribute('href')?.toLowerCase().startsWith('javascript:')) {
                node.setAttribute('href', '#'); // Neutralize javascript: links
             }
         });

        // Hotjar Tracking Code
        (function(h,o,t,j,a,r){
            h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
            h._hjSettings={hjid:3939332,hjsv:6}; // Your HJID
            a=o.getElementsByTagName('head')[0];
            r=o.createElement('script');r.async=1;
            r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
            a.appendChild(r);
        })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');

    </script>
</body>
</html>
